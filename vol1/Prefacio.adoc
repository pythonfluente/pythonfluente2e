:xrefstyle: short
:example-number: 0
:figure-number: 0
:figure-caption: Figura
:example-caption: Exemplo
:table-caption: Tabela
:section-caption: Seção
:chapter-caption: Capítulo
:part-caption: Parte
:sectnums!:

[preface,toclevels=1]
== Prefácio

[quote, Tim Peters, lendário colaborador do CPython e autor do <em>Zen de Python</em>]
____
Eis um plano: se uma pessoa usar um recurso que você não entende, mate-a.
É mais fácil que aprender algo novo, e em pouco tempo os únicos programadores sobreviventes
usarão apenas um subconjunto minúsculo e fácil de entender de Python 0.9.6 <piscadela marota>.footnote:[Mensagem para o grupo da Usenet comp.lang.python em 23 de dezembro de 2002: «_Acrimony in c.l.p_» [.small]#&#91;fpy.li/p-1&#93;# (EN).]
____

"Python é uma linguagem fácil de aprender e poderosa." Essas((("Python", "appreciating language-specific features"))) são as primeiras palavras do «_tutorial oficial de Python 3.10_» [.small]#&#91;fpy.li/p-2&#93;#.
Isso é verdade, mas há uma pegadinha: como a linguagem é fácil de entender e de começar a usar, muitos programadores praticantes de Python se contentam apenas com uma fração de seus poderosos recursos.

Uma programadora experiente pode começar a escrever código Python útil em questão de horas. Conforme as primeiras horas produtivas se tornam semanas e meses, muitos desenvolvedores continuam escrevendo código Python com um forte sotaque das linguagens que aprenderam antes.
Mesmo se Python for sua primeira linguagem, muitas vezes ela é apresentada nas universidades e
em livros introdutórios evitando deliberadamente os recursos específicos da linguagem.

Como professor, ensinando Python para programadores experientes em outras linguagens, vejo outro problema:
só sentimos falta daquilo que conhecemos.
Vindo de outra linguagem, qualquer um é capaz de imaginar que Python suporta expressões regulares,
e procurar esse tema na documentação.
Mas se você nunca viu desempacotamento de tuplas ou descritores de atributos,
talvez nunca procure por eles, e pode acabar não usando esses recursos,
só porque são novos para você.

Este livro não é uma referência exaustiva de Python de A a Z.
A ênfase está em recursos da linguagem característicos de Python
ou incomuns em outras linguagens populares.
Vamos nos concentrar principalmente nos aspectos centrais da linguagem e pacotes essenciais da biblioteca padrão.
Apenas alguns exemplos mostram o uso de pacotes externos como FastAPI, httpx, e Curio.


=== Para quem é esse livro

Escrevi este ((("Python", "versions featured")))
livro para programadores que já usam Python e
desejam se tornar fluentes em Python 3 moderno.
Testei os exemplos em Python 3.10—e a maioria também em Python 3.9 e 3.8.
Os exemplos que exigem especificamente Python 3.10 estão indicados.

Caso((("Python", "prerequisites to learning")))
não tenha certeza se conhece Python o suficiente para acompanhar o livro,
revise o
«_tutorial oficial de Python_» [.small]#&#91;fpy.li/4g&#93;#.
Tópicos tratados no tutorial não serão explicados aqui, exceto por alguns recursos mais novos.


=== Para quem esse livro não é

Se((("Python", "target audience"))) está começando a estudar Python,
poderá achar difícil acompanhar este livro.
Mais ainda, se você o ler muito cedo em sua jornada pela linguagem,
pode ficar com a impressão de que todo script Python precisa se valer
de métodos especiais e truques de metaprogramação.
Abstração prematura é tão ruim quanto otimização prematura.

Para quem está aprendendo a programar, recomendo o livro
«_Pense em Python_» [.small]#&#91;fpy.li/4h&#93;# de Allen Downey, disponível na Web.

Se já sabe programar e está aprendendo Python, o
«_tutorial oficial de Python_» [.small]#&#91;fpy.li/4g&#93;# foi traduzido
pela comunidade Python brasileira.


=== Como ler este livro

Esta edição impressa de _Python Fluente, 2ª Edição_ está dividida em três volumes, contendo as cinco partes do original _Fluent Python, Second Edition_ (O'Reilly, 2022),
que foi publicado em um volume de 1012 páginas.
O texto completo desta edição em português está disponível em
https://pythonfluente.com[pythonfluente.com], em uma única página HTML para facilitar
buscas e a leitura offline.

Recomendo((("Python", "approach to learning", id="Papproach00"))) que todos leiam o <<ch_data_model>>.
Após a leitura do capítulo "O modelo de dados de Python",
o público principal deste livro não terá problema em
pular diretamente para qualquer outra parte ou volume,
mas muitas vezes assumo que você leu os capítulos precedentes de cada parte específica.

Tentei enfatizar o uso de classes e módulos que já existem antes de discutir como criar seus próprios.
Por exemplo, no _Volume 1_,
o <<ch_sequences>> trata dos tipos de sequências que estão prontas para serem usadas,
incluindo algumas que não recebem muita atenção, como `collections.deque`.
Criar sequências definidas pelo usuário só é discutido no _Volume 2, Parte III: Classes e Protocolos_,
onde também vemos como usar as classes base abstratas (ABCs) de `collections.abc`.
Criar suas próprias ABCs é discutido ainda mais tarde naquele volume,
pois acredito na importância de estar confortável usando uma ABC antes de escrever uma.

Essa abordagem tem algumas vantagens.
Primeiro, saber o que está pronto para uso imediato pode evitar que você reinvente a roda.
Usamos as classes de coleções existentes com mais frequência do que implementamos nossas próprias coleções,
e podemos prestar mais atenção ao uso avançado de ferramentas prontas, adiando a discussão sobre a criação de novas ferramentas.
Também é mais comum herdar de ABCs existentes do que criar uma nova ABC do zero.
E, finalmente, acredito que é mais fácil entender as abstrações após vê-las em ação.

A desvantagem dessa estratégia são as referências a pontos futuros espalhadas pelo livro.
Espero que isso seja mais fácil de tolerar agora que você sabe por que escolhi esse caminho.


==== Os três volumes e as 5 partes

O _Fluent Python (Second Edition)_ original é dividido em 5 partes e foi publicado em um volume em inglês.
Nesta edição em português brasileiro, dividimos as 5 partes em 3 volumes.

===== {vo_data_str}

{pa_data} (capítulos 1-6)::
O <<ch_data_model>> introduz o Modelo de Dados de Python e explica por que os
métodos especiais (por exemplo, `+__repr__+`) são a chave do comportamento
consistente de objetos de todos os tipos. Os métodos especiais são tratados em
mais detalhes ao longo do livro. Os((("data structures"))) capítulos restantes
dessa parte cobrem o uso dos tipos de coleção mais importantes:
sequências, mapeamentos e conjuntos,
bem como a separação de `str` e `bytes`--causa de muitas celebrações entre
usuários de Python 3, e de muita dor para usuários de Python 2 obrigados a
migrar suas bases de código. Também são abordadas as fábricas de classe de alto
nível na biblioteca padrão: fábricas de tuplas nomeadas e o decorador
`@dataclass`. _Pattern matching_ ("casamento de padrões")—novidade no Python
3.10—é tratada em seções do <<ch_sequences>>, do <<ch_dicts_sets>> e do
<<ch_dataclass>>, que discutem padrões para sequências, padrões para mapeamentos
e padrões para instâncias de classes. O último capítulo deste volume é sobre o
ciclo de vida dos objetos: criação, referências, mutabilidade e coleta de lixo
(_garbage collection_).

{pa_func_obj_a} (capítulos 7-8):: Aqui explicamos o que significa ter funções
como objetos de primeira classe na linguagem. Também são vistos aqui o conceito
geral de invocáveis no Python e anotação de parâmetros com _type hints_ no
{ch_type_hints_def}.

===== {vo_func_cls}

{pa_func_obj_b} (capítulos 9-10):: Lá desvendamos o conceito de _closure_, a instrução `nonlocal`, e as aplicações destes conceitos na construção de decoradores. Outro tema é o uso de funções de primeira classe para simplificar muito a implementação de alguns padrões de projeto conhecidos.

{pa_cls_proto} (capítulos 11-16):: Agora o foco se volta para a criação "manual" de classes—em contraste com o uso de fábricas de classe vistas no <<ch_dataclass>>.
Como qualquer linguagem orientada a objetos, Python tem seu conjunto particular de recursos que podem ou não estar presentes na linguagem na qual você aprendeu programação baseada em classes. Os capítulos explicam como criar suas próprias coleções, classes base abstratas (ABCs) e protocolos, bem como as formas de lidar com herança múltipla e como implementar a sobrecarga de operadores, quando fizer sentido. O _{ch_more_types}_ continua a conversa sobre dicas de tipo.

===== {vo_ctrl_meta}

{pa_ctrl_flow} (capítulos 17-21):: Nesta parte estudamos as instruções da linguagem e as bibliotecas que vão além do controle de fluxo tradicional
(condicionais, laços e sub-rotinas). Começamos com os geradores, visitamos a seguir os gerenciadores de contexto e as corrotinas,
incluindo a desafiadora e poderosa sintaxe do `yield from`. O _{ch_with_match}_ inclui um exemplo significativo, usando _pattern matching_ em um interpretador de linguagem simples mas funcional. O _{ch_concurrency_models}_ é novo, apresentando uma visão geral das alternativas para processamento concorrente e paralelo no Python, suas limitações, e como a arquitetura de software permite ao Python operar na escala da Web. Reescrevi o capítulo sobre _programação assíncrona_, para enfatizar os recursos centrais da linguagem—por exemplo, `await`, `async def`, `async for` e `async with`, e mostrar como eles são usados com _asyncio_ e outros frameworks.

{pa_metaprog} (capítulos 22-24):: Essa parte começa com uma revisão de técnicas para criação de classes com atributos criados dinamicamente para lidar com dados semi-estruturados, tal como conjuntos de dados JSON. A seguir, tratamos do mecanismo familiar das propriedades, antes de mergulhar no funcionamento do acesso a atributos de objetos no Python em um nível mais baixo, usando descritores. A relação entre funções, métodos e descritores é explicada. Ao longo daquele volume, a implementação passo a passo de uma biblioteca de validação de campos revela questões sutis, levando às ferramentas avançadas do capítulo final: decoradores de classes e metaclasses.


=== Abordagem "mão na massa"

Frequentemente usaremos o console interativo de Python para explorar a linguagem e as bibliotecas.
Acho isso importante para enfatizar o poder dessa ferramenta de aprendizagem,
especialmente para quem teve mais experiência com linguagens estáticas compiladas,
que não oferecem um REPL.footnote:[_Read-Eval-Print Loop_, console interativo
que lê código, executa, e exibe resultados, repetidamente.]

Um dos pacotes padrão de testagem de Python, o «_doctest_» [.small]#&#91;fpy.li/doctest&#93;#, funciona simulando sessões de console e verificando se as expressões resultam nas respostas exibidas. Usei `doctest` para verificar a maior parte do código desse livro, incluindo as listagens do console.
Não é necessário usar ou sequer saber da existência do `doctest` para acompanhar o texto:
a principal característica dos _doctests_ é que eles imitam transcrições de sessões
interativas no console de Python, assim qualquer pessoa pode reproduzir as demonstrações facilmente.

Algumas vezes vou explicar o que queremos realizar mostrando um _doctest_ antes do código que implementa a solução.
Estabelecer precisamente o que deve ser feito, antes de pensar sobre como fazer, ajuda a focalizar nosso esforço de codificação.
Escrever previamente os testes é a base de desenvolvimento dirigido por testes (TDD, _test-driven development_), e também acho essa técnica útil para ensinar.

Também((("pytest package")))((("unittest module"))) escrevi testes unitários para alguns dos exemplos maiores usando _pytest_—que acho mais fácil de usar e mais poderoso que o módulo _unittest_ da biblioteca padrão.
Você vai descobrir que pode verificar a maior parte do código do livro digitando `python3 -m doctest example_script.py` ou `pytest` no console de seu sistema operacional.
A configuração do _pytest.ini_, na raiz do «repositório do código de exemplo» [.small]#&#91;fpy.li/code&#93;#, assegura que _doctests_ são coletados e executados pelo comando `pytest`.((("", startref="Papproach00")))


=== Ponto de vista: minha perspectiva pessoal

Venho usando, ensinando e debatendo Python desde 1998, e gosto de estudar e comparar linguagens de programação,
o design e a teoria por trás delas.
Ao final de cada capítulo, escrevi uma seção "Ponto de vista",
apresentando minha perspectiva sobre Python e outras linguagens.
Você pode pular essas partes, se não tiver interesse em tais discussões.
Seu conteúdo é inteiramente opcional.

=== Conteúdo na Web

Criei dois sites para este livro:

https://pythonfluente.com::
O texto integral em português, traduzido por Paulo Candido de Oliveira Filho,
publicado em um único HTML com todas as dependências embutidas (estilos, imagens, etc.).
O HTML tem apenas diferenças cosméticas em relação a este livro impresso.

https://fluentpython.com::
Contém textos em inglês que complementam as edições do livro, além de um glossário.
É um material que cortei para não ultrapassar o limite de 1.000 páginas.

O repositório de exemplos de código está no «GitHub» [.small]#&#91;fpy.li/code&#93;#.

=== Convenções usadas no livro

As seguintes convenções tipográficas são usadas neste livro:

_Itálico_:: Indica novos termos, URLs, endereços de e-mail, nomes e extensões de arquivos. Nesta edição em português
também usamos _itálico_ em alguns termos mantidos em inglês, principalmente na primeira ocorrência.

`Espaçamento constante`:: Usado em listagens de programas,
bem como dentro de parágrafos para indicar elementos programáticos como identificadores e palavras-chave.

[role="pagebreak-before less_space"]
[TIP]
====
Esse elemento é uma dica ou sugestão.
====

[NOTE]
====
Este elemento é uma nota ou observação.
====

[WARNING]
====
Este elemento é um aviso ou alerta.
====

=== Usando os exemplos de código

Todos((("code examples, obtaining and using"))) os scripts e a maior parte dos trechos de código que aparecem no livro estão disponíveis no repositório de código de Python Fluente, «no GitHub» [.small]#&#91;fpy.li/code&#93;#.

Se você tiver uma questão técnica ou algum problema para usar o código, por favor mande um e-mail para pass:[<a class="e-mail" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>].

Esse livro existe para ajudar você a fazer seu trabalho. Em geral, se um exemplo está no livro, você pode usá-lo em seus programas e na sua documentação. Não é necessário nos contatar para pedir permissão, a menos que você queira reproduzir uma parte significativa do código. Por exemplo, escrever um programa usando vários trechos de código deste livro não exige permissão. Vender ou distribuir exemplos de livros da O’Reilly exige permissão. Responder uma pergunta citando este livro e código exemplo daqui não exige permissão. Incorporar uma parte significativa dos exemplos do livro na documentação de seu produto exige permissão.

Gostamos, mas em geral não exigimos, atribuição da fonte. Isto normalmente inclui o título, o autor, a editora e o ISBN. Por exemplo, “_Fluent Python_, 2ª ed., de Luciano Ramalho. Copyright 2022 Luciano Ramalho, 978-1-492-05635-5.”

Se você achar que seu uso dos exemplos de código está fora daquilo previsto na lei ou das permissões dadas acima, por favor entre em contato com pass:[<a class="e-mail" href="mailto:permissions@oreilly.com"><em>permissions@oreilly.com</em></a>].

=== O'Reilly Online Learning

[role = "ormenabled"]
[NOTE]
====
Por mais de 40 anos, pass:[<a href="http://oreilly.com" class="orm:hideurl"><em class="hyperlink">O’Reilly Media</em></a>] tem oferecido treinamento, conhecimento e ideias sobre tecnologia e negócios, ajudando empresas serem bem sucedidas.
====

Nossa rede sem igual de especialistas e inovadores compartilha conhecimento e sabedoria através de livros, artigos e de nossa plataforma online de aprendizagem. A plataforma de aprendizagem online da O'Reilly oferece acesso sob demanda a treinamentos ao vivo, trilhas de aprendizagem profunda, ambientes interativos de programação e uma imensa coleção de textos e vídeos da O'Reilly e de mais de 200 outras editoras. Para mais informações, visite pass:[<a href="http://oreilly.com" class="orm:hideurl"><em>http://oreilly.com</em></a>].

=== Como entrar em contato

Por gentileza((("comments and questions")))((("questions and comments"))), envie comentários e perguntas sobre esse livro para o editor:

----
O'Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada)
707-829-0515 (international or local)
707-829-0104 (fax)
----

<<<
Há uma página online para o original em inglês deste livro, com erratas e informação adicional,
que pode ser acessada aqui: https://fpy.li/p-4. Envie e-mail para _bookquestions@oreilly.com_, com comentários ou dúvidas técnicas sobre o livro. Novidades e informações sobre nossos livros e cursos podem ser encontradas em _http://oreilly.com_.

=== Agradecimentos da segunda edição brasileira

Meu grande amigo Paulo Candido de Oliveira Filho traduziu as 1000 páginas do
_Fluent Python Second Edition_ (O'Reilly, 2022)
sem poder consultar a outra tradução brasileira,
para não violar os direitos da editora que publicou aquela primeira edição de 2015.
Felizmente, PC e eu somos amigos de infância, trabalhamos juntos como
programadores, então eu pude confiar tranquilamente que ele não ia fazer plágio nem usar IA.
E a tradução ficou excelente: "Engenhocas & Bugigangas" é demais!

Três amigos do Garoa Hacker Clube me ajudaram diretamente nesta edição.
Felipe "Juca" Sanches me orientou sobre tecnologia de fontes,
Gabriel Almeida de Souza fez scripts para resolver as referências entre volumes,
e Hugo Borges me mostrou como configurar um ambiente Ruby flexível
para rodar a ferramenta Asciidoctor com bibliotecas adicionais
para gerar PDF com listagens de código coloridas.
Agradeço a toda a comunidade do Garoa por manter vivo aquele espaço
de criação, aprendizagem e troca de ideias.

Heinar Maracy e Zander Catta Preta da Z•Edições foram muito parceiros em
todas as etapas da produção do livro impresso, desde a diagramação até a campanha no
_https://Catarse.me_, a produção gráfica, e a comercialização na
_https://zstores.shop_ e outras livrarias online.

Muitas pessoas enviaram correções desde que coloquei o _https://PythonFluente.com_ no ar em 2023,
até a reta final da produção do PDF para a gráfica.

Adorilson Bezerra é o primeiro que eu quero citar (não só pela ordem alfabética),
porque é um dos principais voluntários que traduzem
a documentação oficial de Python em português brasileiro,
um trabalho sem fim, mas de valor inestimável para a comunidade Python de língua portuguesa.
Adorilson me mandou sugestões valiosas citando a terminologia adotada na
documentação oficial.

Outras pessoas que enviaram correções e sugestões, grandes ou pequenas:
Alexandre de Siqueira, Ana Paula Sales, André Angeluci, Arturo Fonseca de Souza,
Bruna Menani Pereira Lima, Bruno de Oliveira Pinheiro Júnior, Caio Phillipe Mizerkowski,
Carlos Seabra, Dickson Souza, Diego Mariano, Diego Rabatone Oliveira,
Eduardo Würch, Eric Gonçalves Lemos, Erick R. Ribeiro,
Fabrício Soares, Franklin Sousa, Giovanni Salvatore de Almeida Curcuruto,
Guilherme Henrique Gimenes de Deus, Gustavo de Carvalho Bertoli,
Helder Geovane Gomes de Lima, Inácio Gomes Medeiros, Ismael de Laet Abashi,
Jair Henrique, João Paulo Albuquerque, Juliano Fischer Naves,
Luis Gustavo Mota, Luiz Eduardo Amaral,
Manaia Junior, Mariana Jó, Osvaldo Makoto Yasuda,
Paulo Barbosa de Siqueira Bueno Bruno,
Ramon Gomes da Silva, Raphael Vieira Rossi, Rodolfo De Nadai, Ruan Cardoso Comelli,
Sandra Bastos, Thales Carl Lavoratti, Thiago Brasil, Thiago Gonçalves Mota, Thiago Jack de Oliveira,
Vitor Buxbaum Orlandi, Wellyson de Freitas Santos, e William Ferreira.

Muito grato, pessoal. Foi um prazer colaborar com vocês!


=== Agradecimentos da segunda edição

Eu não esperava que atualizar um livro sobre Python
cinco anos depois fosse um empreendimento de tal magnitude.
Mas foi.
Marta Mello, minha amada esposa, sempre esteve ao meu lado quando precisei.
Meu querido amigo Leonardo Rochael me ajudou desde os primeiros rascunhos até a revisão técnica final,
incluindo consolidar e revisar as sugestões dos outros revisores técnicos, de leitores e de editores.
Honestamente, não sei se teria conseguido sem seu apoio, Marta e Leo. Muito, muito grato!

Jürgen Gmach, Caleb Hattingh, Jess Males, Leonardo Rochael e Miroslav Šedivý formaram a fantástica equipe de revisores técnicos da segunda edição. Eles revisaram o livro inteiro.
Bill Behrman, Bruce Eckel, Renato Oliveira e Rodrigo Bernardo Pimentel revisaram capítulos específicos.
Suas inúmeras sugestões, vindas de diferentes perspectivas, tornaram o livro muito melhor.

Muitos leitores me enviaram correções ou fizeram outras contribuições durante o pré-lançamento, incluindo:
Guilherme Alves, Christiano Anderson, Konstantin Baikov, K. Alex Birch, Michael Boesl, Lucas Brunialti,
Sergio Cortez, Gino Crecco, Chukwuerika Dike, Juan Esteras, Federico Fissore, Will Frey, Tim Gates,
Alexander Hagerman, Chen Hanxiao, Sam Hyeong, Simon Ilincev, Parag Kalra, Tim King, David Kwast,
Tina Lapine, Wanpeng Li, Guto Maia, Scott Martindale, Mark Meyer, Andy McFarland, Chad McIntire, Diego Rabatone Oliveira,
Francesco Piccoli, Meredith Rawls, Michael Robinson, Federico Tula Rovaletti,
Tushar Sadhwani, Arthur Constantino Scardua, Randal L. Schwartz, Avichai Sefati, Guannan Shen, William Simpson,
Vivek Vashist, Jerry Zhang, Paul Zuradzki—e outros que pediram para não ter seus nomes mencionados, enviaram correções após a entrega da versão inicial ou foram omitidos porque eu não registrei seus nomes—mil desculpas.

Durante minha pesquisa, aprendi sobre tipagem, concorrência, _pattern matching_ e metaprogramação interagindo com
Michael Albert, Pablo Aguilar, Kaleb Barrett, David Beazley, J. S. O. Bueno, Bruce Eckel, Martin Fowler,
Ivan Levkivskyi, Alex Martelli, Peter Norvig, Sebastian Rittau, Guido van Rossum, Carol Willing e Jelle Zijlstra.

Os editores da O'Reilly Jeff Bleiel, Jill Leonard e Amelia Blevins fizeram sugestões que melhoraram o fluxo do texto em muitas partes.
Jeff Bleiel e o editor de produção Danny Elfanbaum me apoiaram durante essa longa maratona.

As ideias e sugestões de cada um deles tornaram o livro melhor e mais preciso.
Inevitavelmente, vão restar erros de minha própria criação no produto final. Peço perdão antecipadamente.

Por fim, gostaria de estender meus sinceros agradecimentos a meus colegas na Thoughtworks Brasil—e especialmente a meu mentor, Alexey Bôas, que apoiou este projeto de várias formas até eu terminar a segunda edição em inglês.

Claro, todos os que me ajudaram a entender Python e a escrever a primeira edição merecem agora agradecimentos em dobro.
Não haveria segunda edição sem o sucesso da primeira.

[role="pagebreak-before less_space"]
=== Agradecimentos da primeira edição

O tabuleiro e as peças de xadrez Bauhaus, criadas por Josef Hartwig, são um exemplo de um excelente design: belo, simples e claro.
Guido van Rossum, filho de um arquiteto e irmão de um projetista de fonte magistral, criou uma obra prima do design de linguagens.
Adoro ensinar Python porque ele é belo, simples e claro.

Alex Martelli e Anna Ravenscroft foram os primeiros a ver o esquema desse livro, e me encorajaram a submetê-lo à O'Reilly para publicação.
Seus livros me ensinaram Python idiomático e são modelos de clareza, precisão e profundidade em escrita técnica.
Os mais de 6.200 posts de «Alex no Stack Overflow» [.small]#&#91;fpy.li/p-7&#93;# são uma fonte de boas ideias sobre a linguagem e seu uso apropriado.

Martelli e Ravenscroft foram também revisores técnicos deste livro, juntamente com Lennart Regebro e Leonardo Rochael. Todos nesta proeminente equipe de revisão técnica têm pelo menos 15 anos de experiência com Python, com muitas contribuições a projetos Python de alto impacto, em contato constante com outros desenvolvedores da comunidade. Em conjunto, eles me enviaram centenas de correções, sugestões, questões e opiniões, acrescentando imenso valor ao livro. Victor Stinner revisou o _{ch_async}_, trazendo seu conhecimento especializado, como um dos mantenedores do `asyncio`, para a equipe de revisão técnica. Foi um grande privilégio e um prazer colaborar com eles por estes muitos meses.

A editora Meghan Blanchette foi uma fantástica mentora, e me ajudou a melhorar a organização e o fluxo do texto do livro, me mostrando que partes estavam monótonas e evitando que eu atrasasse o projeto ainda mais. Brian MacDonald editou os capítulos da _Parte II_ quando Meghan estava ausente. Adorei trabalhar com eles e com todos na O'Reilly, incluindo a equipe de suporte e desenvolvimento do Atlas (Atlas é a plataforma de publicação de livros da O'Reilly, que usei para escrever esse livro).

Mario Domenech Goulart deu sugestões numerosas e detalhadas, desde a primeira versão do livro. Também recebi muitas sugestões e comentários de Dave Pawson, Elias Dorneles, Leonardo Alexandre Ferreira Leite, Bruce Eckel, J. S. Bueno, Rafael Gonçalves, Alex Chiaranda, Guto Maia, Lucas Vido e Lucas Brunialti.

Ao longo dos anos, muitas pessoas me encorajaram a me tornar um autor, mas os mais persuasivos foram Rubens Prates, Aurelio Jargas, Rudá Moura e Rubens Altimari. Mauricio Bussab me abriu muitas portas, incluindo minha primeira experiência real na escrita de um livro. Renzo Nuccitelli apoiou este projeto de escrita o tempo todo, mesmo quando significou iniciar mais lentamente nossa parceria no pass:[<a href="https://fpy.li/p-8" class="orm:hideurl"><em>python.pro.br</em></a>].

A maravilhosa comunidade brasileira de Python é inteligente, generosa e divertida. O «grupo Python Brasil» [.small]#&#91;fpy.li/p-9&#93;# tem milhares de membros, e nossas conferências nacionais e regionais reúnem centenas de pessoas. Mas os mais influentes em minha jornada como pythonista foram Leonardo Rochael, Adriano Petrich, Daniel Vainsencher, Rodrigo RBP Pimentel, Bruno Gola, Leonardo Santagada, Jean Ferri, Rodrigo Senra, J. S. Bueno, David Kwast, Luiz Irber, Osvaldo Santana, Fernando Masanori, Henrique Bastos, Gustavo Niemayer, Pedro Werneck, Gustavo Barbieri, Lalo Martins, Danilo Bellini, e Pedro Kroger.

Dorneles Tremea foi um grande amigo, (e incrivelmente generoso com seu tempo e seu conhecimento), um hacker fantástico e o mais inspirador líder da Associação Python Brasil. Ele nos deixou cedo demais.

Meus estudantes, ao longo desses anos, me ensinaram muito através de suas perguntas, ideias, feedbacks e soluções criativas para problemas. Érico Andrei e a Simples Consultoria me deram a oportunidade de ser um professor de Python em tempo integral pela primeira vez.

Martijn Faassen foi meu mentor de Grok e compartilhou ideias valiosas sobre Python e os neandertais. Seu trabalho e o de Paul Everitt, Chris McDonough, Tres Seaver, Jim Fulton, Shane Hathaway, Lennart Regebro, Alan Runyan, Alexander Limi, Martijn Pieters, Godefroid Chapelle e outros, dos planetas Zope, Plone e Pyramid, foram decisivos para minha carreira. Graças ao Zope e a surfar na primeira onda da web, pude começar a ganhar a vida com Python em 1998. José Octavio Castro Neves foi meu sócio na primeira software house baseada em Python do Brasil.

Tenho gurus demais na grande comunidade Python para listar todos aqui, mas além daqueles já mencionados, eu tenho uma dívida com Steve Holden, Raymond Hettinger, A.M. Kuchling, David Beazley, Fredrik Lundh, Doug Hellmann, Nick Coghlan, Mark Pilgrim, Martijn Pieters, Bruce Eckel, Michele Simionato, Wesley Chun, Brandon Craig Rhodes, Philip Guo, Daniel Greenfeld, Audrey Roy e Brett Slatkin, por me ensinarem novas e melhores formas de ensinar Python.

A maior parte dessas páginas foi escrita no meu _home office_ e em dois laboratórios: o CoffeeLab e o Garoa Hacker Clube. O «CoffeeLab» [.small]#&#91;fpy.li/p-10&#93;# é o quartel-general dos geeks cafeinados na Vila Madalena, em São Paulo, Brasil. O «Garoa Hacker Clube» [.small]#&#91;fpy.li/p-11&#93;# é um espaço hacker aberto a todos: um laboratório comunitário onde qualquer pessoa pode experimentar novas ideias.

<<<
A comunidade Garoa me forneceu inspiração, infraestrutura e distração. Acho que o Aleph curtiria este livro.

Minha mãe, Maria Lucia, e meu pai, Jairo, sempre me apoiaram de todas as formas. Gostaria que ele estivesse aqui para ver esse livro; e fico feliz de poder compartilhá-lo com ela.

Minha esposa, Marta Mello, esteve ao meu lado durante os 15 meses em que trabalhei neste livro,
sempre me apoiando e guiando através dos momentos mais críticos,
quando temi que poderia abandonar a maratona.

Agradeço a todos vocês por tudo.


=== Sobre esta tradução

_Python Fluente, 2ª Edição_
é uma tradução direta de _Fluent Python, Second Edition_ (O'Reilly, 2022).
Não é uma obra derivada de _Python Fluente_ (Novatec, 2015).

A presente tradução foi autorizada pela O'Reilly Media para distribuição nos termos da licença
«CC BY-NC-ND» [.small]#&#91;fpy.li/4j&#93;#.
Os arquivos-fonte em formato _Asciidoc_ estão no repositório público
https://github.com/pythonfluente/pythonfluente2e.


[NOTE]
====
Correções e sugestões de melhorias são bem vindas!
Para contribuir, veja os
«__issues__» [.small]#&#91;fpy.li/4m&#93;#
no repositório https://github.com/pythonfluente/pythonfluente2e.
====

=== Histórico das traduções

Escrevi a primeira e a segunda edições deste livro originalmente em inglês,
para serem mais facilmente distribuídas no mercado internacional.

Cedi os direitos exclusivos para a O'Reilly Media,
nos termos usuais de contratos com editoras famosas:
elas ficam com a maior parte do lucro, o direito de publicar, e
o direito de vender licenças para tradução em outros idiomas.

Até 2022, a primeira edição foi publicada nesses idiomas:

<<<
. inglês,
. português brasileiro,
. chinês simplificado (China),
. chinês tradicional (Taiwan),
. japonês,
. coreano,
. russo,
. francês,
. polonês.

A ótima tradução PT-BR foi produzida e publicada
no Brasil pela Editora Novatec em 2015, sob licença da O'Reilly.

Entre 2020 e 2022, atualizei e expandi bastante o livro para a segunda edição.
Sou muito grato à liderança da
«Thoughtworks Brasil» [.small]#&#91;fpy.li/4n&#93;#
por terem me apoiado enquanto passei a maior parte de 2020 e 2021
pesquisando, escrevendo, e revisando esta edição.

Quando entreguei o manuscrito para a O'Reilly,
negociei um adendo contratual para liberar a tradução da
segunda edição em PT-BR com uma licença livre,
como uma contribuição para a comunidade Python lusófona.
A O'Reilly autorizou que essa tradução fosse publicada sob a licença CC BY-NC-ND:
«Creative Commons — Atribuição-NãoComercial-SemDerivações 4.0 Internacional»
[.small]#&#91;fpy.li/4j&#93;#.
Com essa mudança contratual,
a Editora Novatec não teve interesse em traduzir e publicar a segunda edição.

Contratei Paulo Candido de Oliveira Filho
para traduzir. Fiz a revisão técnica com ajuda da comunidade,
gerei os arquivos HTML com «Asciidoctor» [.small]#&#91;fpy.li/4p&#93;#
e publiquei em https://PythonFluente.com.

E agora, finalmente, temos a segunda edição em português impressa!

_Luciano Ramalho, São Paulo, 24 de setembro de 2025_

<<<
