# Aqruivo conténdo as ancoras de cada capítulo
[ch_data_model]
pythonic_card_deck = Um baralho pythônico
ex_pythonic_deck = .Um baralho como uma sequência de cartas
how_special_used = Como os métodos especiais são utilizados
data_model_emulating_sec = Emulando tipos numéricos
vectors_fig = .Soma de vetores bi-dimensionais; `Vector(2, 4) + Vector(2, 1)` devolve `Vector(4, 5)`.
ex_vector2d = .Uma classe simples para representar um vetor 2D.
repr_intro = Representação como string
collection_api = A API de Collection
collection_uml = .Diagrama de classes UML com os tipos fundamentais de coleções. Métodos com nome em _itálico_ são abstratos, então precisam ser implementados pelas subclasses concretas, como `list` e `dict`. O restante dos métodos tem implementações concretas, então as subclasses podem herdá-los.
overview_special_methods = Visão geral dos métodos especiais
special_names_tbl = .Nomes de métodos especiais (excluindo operadores)
special_operators_tbl = .Nomes e símbolos de métodos especiais para operadores

[ch_sequences]
container_v_flat_img = .Diagramas de memória simplificados mostrando uma `tuple` e um `array`, cada uma com três itens. As células em cinza representam o cabeçalho de cada objeto Python na memória. A `tuple` tem um array de ponteiros para seus itens. Cada item é um objeto Python separado, possivelmente contendo também referências aninhadas a outros objetos Python, como aquela lista de dois itens. Por outro lado, um `array` Python é um único objeto, contendo um array da linguagem C com três números de ponto flutuante no formato nativo da CPU.
sequence_uml = .Diagrama de classe UML simplificado para algumas classes de collections.abc (as superclasses estão à esquerda; as setas de herança apontam das subclasses para as superclasses; nomes em itálico indicam classes e métodos abstratos).
ex_build_list = .Cria uma lista de códigos Unicode a partir de uma string
ex_listcomp0 = .Cria uma lista de códigos Unicode a partir de uma string, usando uma listcomp
ex_listcomp_x_filter_map = .A mesma lista, criada por uma listcomp e por uma composição de map/filter
cartesian_product_sec = Produtos cartesianos
cartesian_product_fig = .O produto cartesiano de 3 valores de cartas e 4 naipes é uma sequência de 12 itens.
ex_listcomp_cartesian = .Produto cartesiano usando uma compreensão de lista
ex_genexp_load = .Inicializando uma tupla e um array a partir de uma expressão geradora
ex_genexp_cartesian = .Produto cartesiano em uma expressão geradora
tuples_more_than_lists_sec = Tuplas não são apenas listas imutáveis
ex_tuples_as_records = .Tuplas usadas como registros
tuple_mutable = .O conteúdo em si da tupla é imutável, mas isso significa apenas que as referências mantidas pela tupla vão sempre apontar para os mesmos objetos. Entretanto, se um dos objetos referenciados for mutável—uma lista, por exemplo—seu conteúdo pode mudar.
list_x_tuple_attrs_tbl = .Métodos e atributos encontrados em `list` ou `tuple` (os métodos implementados por `object` foram omitidos para economizar espaço)
iterable_unpacking_sec = Desempacotando sequências e iteráveis
tuple_star = Usando * para recolher itens em excesso
ex_nested_tuple = .Desempacotando tuplas aninhadas para acessar a longitude
sequence_patterns_sec = Pattern matching com sequências
ex_robot = .Método de uma classe `Robot` imaginária
ex_nested_tuple_match = .Desestruturando tuplas aninhadas—requer Python ≥ 3.10
pattern_matching_seq_interp_sec = Casando padrões de sequência em um interpretador
ex_norvigs_eval = .Casando padrões sem `match/case`
ex_match_eval = .Pattern matching com `match/case`—requer Python ≥ 3.10
syntax_and_pattern_tbl = .Algumas formas sintáticas do Scheme e os padrões de `case` para tratá-las
slice_objects = Objetos fatia
flat_file_invoce = .Itens de um arquivo tabular de fatura
assigning_to_slices = Atribuindo a fatias
ex_list_of_lists_ok = .Uma lista com três listas de tamanho 3 pode representar um tabuleiro de jogo da velha
ex_list_of_lists_wrong = .Uma lista com três referências para a mesma lista é inútil
aug_assign_seqs = Atribuição aumentada com sequências
tuple_puzzler = Um quebra-cabeça com a atribuição +=
ex_aug_item_assign_question = .Um enigma
ex_aug_item_assign_solution = .O resultado inesperado: o item t2 é modificado _e_ uma exceção é gerada
aug_item_assign_tutor = .Estados inicial e final do enigma da atribuição de tuplas (diagrama gerado pelo Online Python Tutor).
ex_aug_item_assign_bytecode = .Bytecode para a expressão `s[a] += b`
sort_x_sorted = list.sort versus a função embutida sorted
arrays_sec = Arrays
ex_array_io = .Criando, armazenando e carregando uma grande array de números de ponto flutuante.
list_x_array_attrs_tbl = .Métodos e atributos encontrados em `list` ou `array` (os métodos descontinuados de array e aqueles implementados também pir object foram omitidos para preservar espaço)
memoryview_sec = Views de memória
ex_memoryview_demo = .Manipular 6 bytes de memória como views de 1×6, 2×3, e 3×2
ex_memoryview_evil_demo = .Mudando o valor de um item em um array de inteiros de 16 bits trocando apenas o valor de um de seus bytes
numpy_sec = NumPy
ex_numpy_array = .Operações básicas com linhas e colunas em uma `numpy.ndarray`
ex_deque = .Usando um `deque`
list_x_deque_methods_tbl = .Métodos implementados em `list` ou `deque` (aqueles também implementados por `object` foram omitidos para preservar espaço)
array_fur_reading_sec = Leitura complementar
sequences_soapbox = .Ponto de Vista

[ch_dicts_sets]
modern_dict_syntax_sec = A sintaxe moderna dos dicts
dictcomp_sec = Compreensões de dict
example3-1 = .Exemplos de compreensões de `dict`
dict_unpacking_sec = Desempacotando mapeamentos
pattern_matching_mappings_sec = Pattern matching com mapeamentos
dict_match_ex = .creator.py: `get_creators()` extrai o nome dos criadores em registros de mídia
mapping_uml = .Diagrama de classe simplificado para `MutableMapping` e suas superclasses de `collections.abc` (as setas de herança apontam das subclasses para as superclasses; nomes em itálico indicam classes e métodos abstratos
what_is_hashable = O que é hashable?
mapping_methods_tbl = .Métodos do tipos de mapeamento `dict`, `collections.defaultdict`, e `collections.OrderedDict` (métodos comuns de `object` omitidos por concisão); argumentos opcionais então entre `[…]`
index0_output_ex = .Saída parcial do <<index0_ex>> processando o texto "Zen of Python"; cada linha mostra uma palavra e uma lista de ocorrências na forma de pares `(line_number, column_number)` (número da linha, número da coluna).
index0_ex = .index0.py usa `dict.get` para obter e atualizar uma lista de ocorrências de palavras de um índice (uma solução melhor é apresentada no <<index_ex>>)
index_ex = .index.py usa `dict.setdefault` para obter e atualizar uma lista de ocorrências de uma palavra em uma única linha de código; compare com o <<index0_ex>>
mappings_flexible_sec = Tratamento automático de chaves ausentes
defaultdict_sec = defaultdict: outra perspectiva sobre as chaves ausentes
index_default_ex = .index_default.py: usando um `defaultdict` em vez do método `setdefault`
missing_method = O método +__missing__+
ex_strkeydict0_tests = .Ao buscar por uma chave não-string, `StrKeyDict0` a converte para `str` quando ela não é encontrada
ex_strkeydict0 = .`StrKeyDict0` converte chaves não-string para string no momento da consulta (vejas os testes no <<ex_strkeydict0_tests>>)
inconsistent_missing = O uso inconsistente de +__missing__+ na biblioteca padrão
ordereddict_sec = collections.OrderedDict
chainmap_sec = collections.ChainMap
sublcassing_userdict_sec = Criando subclasses de UserDict em vez de dict
ex_strkeydict = .`StrKeyDict` sempre converte chaves que não sejam strings para `str` na inserção, atualização e busca
ex_MappingProxyType = .`MappingProxyType` cria uma instância somente de leitura de `mappingproxy` a partir de um `dict`
dictionary_views_sec = Views de dicionários
ex_dict_values = .O método `.values()` devolve uma view dos valores em um `dict`
conseq_dict_internal_sec = Consequências práticas da forma como dict funciona
ex_set_ops_ex = .Conta as ocorrências de agulhas (_needles_) em um palheiro (_haystack_), ambos do tipo set
ex_set_loop_ex = .Conta as ocorrências de agulhas (_needles_) em um palheiro (_haystack_); mesmo resultado final do  <<ex_set_ops_ex>>
ex_set_ops_ex2 = .Conta as ocorrências de agulhas (_needles_) em um palheiro (_haystack_); essas linhas funcionam  para qualquer tipo iterável
ex_setcomp = .Cria um conjunto de caracteres Latin-1 que tenham a palavra "SIGN" em seus nomes Unicode
consequences_set_sec = Consequências práticas da forma de funcionamento dos conjuntos
set_op_section = Operações de conjuntos
set_uml = .Diagrama de classes UML simplificado para `MutableSet` e suas superclasses em `collections.abc` (nomes em itálico são classes e métodos abstratos; métodos de operadores reversos foram omitidos por concisão).
set_operators_tbl = .Operações matemáticas com conjuntos: esses métodos produzem um novo conjunto ou atualizam o conjunto alvo no mesmo lugar, se ele for mutável
set_comparison_tbl = .Operadores e métodos de comparação de conjuntos que devolvem um booleano
set_methods_tbl = .Métodos adicionais de conjuntos
set_ops_dict_views_sec = Operações de conjuntos em views de dict
view_methods_tbl = .Métodos implementados por `frozenset`, `dict_keys`, e `dict_items`
further_reading_dict = Leitura complementar

[ch_str_bytes]
ex_encode_decode = .Codificando e decodificando
ex_bytes_bytearray = .Uma sequência de cinco bytes, como `bytes` e como `bytearray`
ex_buffer_demo = .Inicializando bytes a partir de dados brutos de um array
ex_codecs = .A string "El Niño" codificada com três codecs, gerando sequências de bytes muito diferentes
encodings_demo_fig = .Doze caracteres, seus pontos de código, e sua representação binária (em hexadecimal) em 7 codificações diferentes (asteriscos indicam que o caractere não pode ser representado naquela codificação).
ex_encoding = .Encoding to bytes: success and error handling
ex_decoding = .Decodificando de `str` para bytes: sucesso e tratamento de erro
syntax_error_encoding = SyntaxError ao carregar módulos com codificação inesperada
ex_ola_mundo = .'ola.py': um "Hello, World!" em português
discover_encoding = Como descobrir a codificação de uma sequência de bytes
unicode_sandwich_fig = .O sanduíche de Unicode: a melhor prática para processamento de texto.
ex_cafe_file1 = .Uma questão de plataforma na codificação (você pode ou não ver o problema se tentar isso na sua máquina)
ex_cafe_file2 = .Uma inspeção mais atenta do <<ex_cafe_file1>> rodando no Windows revela o bug e a solução do problema
encoding_defaults = Cuidado com os defaults de codificação
ex_default_encodings = .Explorando os defaults de codificação
ex_default_encodings_ps = .Codificações default, no PowerShell do Windows 10 (a saída é a mesma no cmd.exe)
ex_stdout_check = .stdout_check.py
fig_stdout_check = .Executando _stdout_check.py_ no PowerShell.
fig_stdout_check_redir = .Executanto _stdout_check.py_ no PowerShell, redirecionando a saída.
normalizing_unicode = Normalizando o Unicode para comparações confiáveis
ex_normeq = .normeq.py: normalized Unicode string comparison
ex_shave_marks = .simplify.py: função para remover todas as marcações combinadas
ex_shave_marks_demo = .Dois exemplos de uso da `shave_marks` do <<ex_shave_marks>>
ex_shave_marks_latin = .Função para remover marcações combinadas de caracteres latinos (comando de importação omitidos, pois isso é parte do módulo simplify.py do <<ex_shave_marks>>)
ex_asciize = .Transforma alguns símbolos tipográficos ocidentais em ASCII (este trecho também é parte do simplify.py do <<ex_shave_marks>>)
ex_asciize_demo = .Dois exemplos usando `asciize`, do <<ex_asciize>>
sorting_unicode_sec = Ordenando texto Unicode
ex_locale_sort = ._locale_sort.py_: Usando a função `locale.strxfrm` como chave de ornenamento
ex_pyuca_sort = .Utilizando o método `pyuca.Collator.sort_key`
unicodedata_sec = O banco de dados do Unicode
finding_chars_sec = Encontrando caracteres por nome
unicodedata_name_fig = .Explorando `unicodedata.name()` no console de Python.
cf_demo_fig = .Usando _cf.py_ para encontrar gatos sorridentes.
ex_cfpy = .cf.py: o utilitário de busca de caracteres
ex_numerics_demo = .Demo do banco de dados Unicode de metadados de caracteres numéricos
numerics_demo_fig = .Terminal do macOS mostrando os caracteres numéricos e metadados correspondentes; `re_dig` significa que o caractere casa com a expressão regular `r'\d'`.
dual_mode_api_sec = APIs de modo dual para str e bytes
ex_re_demo = .ramanujan.py: compara o comportamento de expressões regulares simples como `str` e como `bytes`
fig_re_demo = .Captura de tela da execução de ramanujan.py do <<ex_re_demo>>.
ex_listdir1 = .`listdir` com argumentos `str` e `bytes`, e os resultados

[ch_dataclass]
data_class_overview_sec = Visão geral das fábricas de classes de dados
coord_class_ex = ._class/coordinates.py_
coord_tuple_ex = ._typing_namedtuple/coordinates.py_
coord_dataclass_ex = ._dataclass/coordinates.py_
dc_main_features_sec = Principais recursos
builders_compared_tbl = .Recursos selecionados, comparando as três fábricas de classes de dados; `x` é uma instância de uma classe de dados daquele tipo
class_syntax_feature = Sintaxe de declaração de classe
classic_named_tuples_sec = Tuplas nomeadas clássicas
ex_named_tuple_1 = .Definindo e usando um tipo tupla nomeada
ex_named_tuple_2 = .Atributos e métodos das tuplas nomeadas (continuando do exenplo anterior)
ex_coord_tuple_default = .Atributos e métodos das tuplas nomeadas, continuando do <<ex_named_tuple_2>>
hacking_namedtuple_box = .Remendando uma tupla nomeada para injetar um método
ranked_card_ex = .frenchdeck.doctest: Acrescentando um atributo de classe e um método a `Card`, a `namedtuple` da <<pythonic_card_deck>>
typed_named_tuples_sec = Tuplas nomeadas com tipo
coord_tuple_default_ex = ._typing_namedtuple/coordinates2.py_
no_runtime_effect_sec = Nenhum efeito durante a execução
no_runtime_check_ex = .Python não checa dicas de tipo durante a execução de um programa
var_annotation_syntax = Sintaxe de anotação de variáveis
ex_demo_plain = .meaning/demo_plain.py: uma classe básica com dicas de tipo
ex_demo_nt = .meaning/demo_nt.py: uma classe criada com `typing.NamedTuple`
inspecting_dataclass_sec = Inspecionando uma classe decorada com dataclass
ex_demo_dc = .meaning/demo_dc.py: uma classe decorada com `@dataclass`
dataclass_options_tbl = .Parâmetros nomeados aceitos pelo decorador `@dataclass`
field_options_sec = Opções de campo
club_wrong_ex = ._dataclass/club_wrong.py_: essa classe gera um `ValueError`
club_ex = ._dataclass/club.py_: essa definição de `ClubMember` funciona
club_generic_ex = ._dataclass/club_generic.py_: essa definição de `ClubMember` é mais precisa
field_options_tbl = .Argumentos nomeados aceitos pela função `field`
hackerclub_doctests_ex = ._dataclass/hackerclub.py_: doctests para `HackerClubMember`
hackerclub_ex = ._dataclass/hackerclub.py_: código para `HackerClubMember`
initvar_ex = .Exemplo da documentação do módulo https://fpy.li/3v[`dataclasses`]
dc_resource_sec = Exemplo de @dataclass: o registro de recursos do Dublin Core
resource_ex = ._dataclass/resource.py_: código de `Resource`, uma classe baseada nos termos do Dublin Core
resource_doctest_ex = ._dataclass/resource.py_: código de `Resource`, uma classe baseada nos termos do Dublin Core
resource_repr_ex = .`dataclass/resource_repr.py`: código para o método `+__repr__+`, implementado na classe `Resource` do <<resource_ex>>
dataclass_code_smell_sec = A classe de dados como _cheiro no código_
code_smell_essay = .Cheiros no Código
pattern_instances_sec = Pattern Matching com instâncias de classes
keyword_class_patterns_sec = Padrões de classe nomeados
ex_cities_match = .A classe `City` e algumas instâncias
positional_class_patterns_sec = Padrões de classe posicionais
dataclass_further_sec = Leitura complementar

[ch_refs_mut_mem]
ex_a_b_refs = .As variáveis a e b mantém referências para a mesma lista, não cópias da lista.
var-boxes-x-labels = .Se você imaginar variáveis como caixas, não é possível entender a atribuição em Python; por outro lado, imagine variáveis como etiquetas autocolantes e o <<ex_a_b_refs>> é facilmente explicável.
ex_var_assign_after = .Variáveis são vinculadas a objetos somente após os objetos serem criados
ex_equal_and_same = .`charles` e `lewis` se referem ao mesmo objeto
alias_x_copy = .`charles` e `lewis` estão vinculados ao mesmo objeto; `alex` está vinculado a um objeto diferente de valor igual.
ex_equal_not_same = .`alex` e `charles` são iguais quando comparados, mas `alex` _não é_ `charles`
choosing_eq_v_is_sec = Escolhendo Entre == e is
tuple-relative-immutable = A imutabilidade relativa das tuplas
ex_mutable_tuples = .`t1` e `t2` inicialmente são iguais, mas a mudança em um item mutável dentro da tupla `t1` as torna diferentes
ex_shallow_copy = .Criando uma cópia rasa de uma lista contendo outra lista; copie e cole esse código para vê-lo animado no Online Python Tutor
shallow_copy1 = .Estado do programa imediatamente após a atribuição `l2 = list(l1)` em <<ex_shallow_copy>>. `l1` e `l2` se referem a listas diferentes, mas as listas compartilham referências para um mesmo objeto interno, a lista `[66, 55, 44]` e para a tupla `(7, 8, 9)`. (Diagrama gerado pelo Online Python Tutor)
ex_shallow_copy_out = .Saída de <<ex_shallow_copy>>
shallow_copy2 = .Estado final de `l1` e `l2`: elas ainda compartilham referências para o mesmo objeto lista, que agora contém `[66, 44, 33, 22]`, mas a operação `l2[2] += (10, 11)` criou uma nova tupla com conteúdo `(7, 8, 9, 10, 11)`, sem relação com a tupla `(7, 8, 9)` referenciada por `l1[2]`. (Diagram generated by the Online Python Tutor.)
deep_x_shallow_copies = Cópias profundas e cópias rasas
ex_bus1 = .Bus pega ou deixa passageiros
ex_bus1_console = .Os efeitos do uso de `copy` versus `deepcopy`
ex_cycle1 = .Referências cíclicas: `b` tem uma referência para `a` e então é concatenado a `a`; ainda assim, `deepcopy` consegue copiar `a`.
ex_param_pass = .Uma função pode mudar qualquer objeto mutável que receba
mutable_default_parameter_sec = Porque evitar tipos mutáveis como default em parâmetros
ex_haunted_bus = .Uma classe simples ilustrando o perigo de um default mutável
demo_haunted_bus = .Ônibus assombrados por passageiros fantasmas
defensive_argument = Programação defensiva com argumentos mutáveis
demo_twilight_bus = .Passageiros desaparecem quando são deixados por um `TwilightBus`
ex_twilight_bus = .Uma classe simples mostrando os perigos de mudar argumentos recebidos
del_sec = del e coleta de lixo
ex_finalize = .Assistindo o fim de um objeto quando não resta nenhuma referência apontando para ele
ex_same_tuple = .Uma tupla construída a partir de outra é, na verdade, exatamente a mesma tupla.
ex_same_string = .Strings literais podem criar objetos compartilhados.

[ch_func_objects]
func_object_demo = .Cria e testa uma função, e então lê seu `+__doc__+` e verifica seu tipo
factorial_help = .Tela de ajuda para `factorial`; o texto é criado a partir do atributo `+__doc__+` da função.
func_object_demo2 = .Invoca `factorial` através da variável `fact`, e passa `factorial` como argumento para `map`
higher_order_sort = .Ordenando uma lista de palavras por tamanho
higher_order_sort_reverse = .Ordenando uma lista de palavras pela ordem inversa de escrita
map_filter_reduce = Substitutos modernos para map, filter, e reduce
reduce_x_sum = .Listas de fatoriais produzidas com `map` e `filter`, comparadas com alternativas escritas com compreensões de lista
reduce_x_sum2 = .Soma de inteiros até 99, realizada com `reduce` e `sum`
higher_order_sort_reverse_lambda = .Ordenando uma lista de palavras escritas na ordem inversa usando `lambda`
flavors_of_callables = Os nove sabores de objetos invocáveis
user_callables = Tipos invocáveis definidos pelo usuário
ex_bingo_callable = .bingocall.py: Uma `BingoCage` faz apenas uma coisa: escolhe itens de uma lista embaralhada
tagger_ex = .`tag` gera elementos HTML; um argumento somente nomeado `class_` é usado para passar atributos "class"; o `_` é necessário porque `class` é uma palavra reservada no Python
tagger_demo = .Algumas das muitas formas de invocar a função `tag` do <<tagger_ex>>
positional_only_params = Parâmetros somente posicionais
operator_module_section = O módulo operator
fact_reduce_lambda_ex = .Fatorial implementado com `reduce`e uma função anônima
fact_reduce_operator_ex = .Fatorial implementado com `reduce` e `operator.mul`
itemgetter_demo = .Demonstração de `itemgetter` para ordenar uma lista de tuplas (mesmos dados do <<ex_nested_tuple>>)
attrgetter_demo = .Demonstração de `attrgetter` para processar uma lista previamente definida de `namedtuple` chamada `metro_data` (a mesma lista que aparece no <<itemgetter_demo>>)
methodcaller_demo = .Demonstração de `methodcaller`: o segundo teste mostra a vinculação de argumentos adicionais
functools_partial_sec = Fixando argumentos com functools.partial
ex_partial_mul = .Empregando `partial` para usar uma função com dois argumentos onde é necessário um invocável com apenas um argumento
ex_partial_nfc = .Criando uma função conveniente para normalizar Unicode com `partial`
partial_demo = .Demonstração de `partial` aplicada à função `tag`, do <<tagger_ex>>
first_cls_fn_further_reading_sec = Leitura complementar
soapbox_1st_class_fn = .Ponto de vista

[ch_type_hints_def]
msgs_no_hints = .`show_count` de _messages.py_ sem dicas de tipo.
msgs_test_no_hints = ._messages_test.py_ sem dicas de tipo.
msgs_optional_str_param = .`showcount` de _hints_2/messages.py_ com um argumento opcional
dealing_with_none_sec = Usando None como default
types_defined_by_ops_sec = Tipos são definidos pelas operações possíveis
birds_module_ex = ._birds.py_
daffy_module_ex = ._daffy.py_
woody_module_ex = ._woody.py_
birdie_errors_ex = .Erros durante a execução e como o Mypy poderia ter ajudado
consistent_with_sec = Subtipo-de ou consistente-com
int_complex_tip = .int é consistente-com complex
simple_collections_type_sec = Coleções genéricas
tokenize_ex = .`tokenize` com dicas de tipo para Python ≥ 3.9
legacy_deprecated_typing_box = .Suporte a tipos de coleção descontinuados
tokenize_3_7_ex = .`tokenize` com dicas de tipo para Python ≥ 3.7
tokenize_3_5_ex = .`tokenize` com dicas de tipo para Python ≥ 3.5
generic_collections_tbl = .Alguns tipos de coleção e seus equivalentes nas dicas de tipo
tuple_type_sec = Tipos tuple
geohash_ex_1 = ._coordinates.py_ com a função `geohash`
geohash_ex_2 = ._coordinates_named.py_ com `NamedTuple`, `Coordinates` e a função `geohash`
columnize_ex = ._columnize.py_ retorna uma lista de tuplas de strings
mapping_type_sec = Mapeamentos genéricos
charindex_ex = ._charindex.py_
type_hint_abc_sec = Classes bases abstratas
numeric_tower_warning = A queda da torre numérica
replacer_ex = ._replacer.py_
param_generics_typevar_sec = Genéricos parametrizados e TypeVar
generic_sample_ex = ._sample.py_
mode_float_ex = ._mode_float.py_: `mode` que opera com `float` e seus subtipos footnote:[A implementação aqui é mais simples que aquela do módulo https://fpy.li/8-29[`statistics`] na biblioteca padrão de Python]
typevar_constraints_sec = TypeVar restrita
bounded_typevar_sec = TypeVar delimitada
mode_hashable_ex = ._mode_hashable.py_: igual a <<mode_float_ex>>, mas com uma assinatura mais flexível
protocols_in_fn = Protocolos estáticos
top_undefined_t_ex = .a função `top` function com um parâmetro de tipo `T` indefinido
comparable_protocol_ex = ._comparable.py_: a definição de um tipo `Protocol`, `SupportsLessThan`
top_protocol_ex = ._top.py_: definição da função `top` usando uma `TypeVar` com `bound=SupportsLessThan`
top_protocol_test = ._top_test.py_: visão parcial da bateria de testes para `top`
top_protocol_mypy_output = .Saída do _mypy top_test.py_ (linha quebradas para facilitar a leitura)
callable_variance_sec = Variância em tipos callable
callable_variance_ex = .Ilustrando a variância.
noreturn_sec = NoReturn
arbitrary_arguments_sec = Anotando parâmetros apenas posicionais e variádicos
type_hints_in_def_soapbox = .Ponto de vista

[ch_closure_decorator]
decorator_replaces = .Um decorador normalmente substitui uma função por outra, diferente
registration_ex = .O módulo registration.py
registration_deco_sec = Decoradores de registro
ex_global_undef = .Função lendo uma variável local e uma variável global
ex_local_unbound = .A variável `b` é local, porque um valor é atribuído a ela no corpo da função
ex_f1_dis = .Bytecode da função `f1` do <<ex_global_undef>>
ex_f2_dis = .Bytecode da função `f2` do <<ex_local_unbound>>
closures_sec = Clausuras
ex_average_oo = .average_oo.py: uma classe para calcular uma média contínua
ex_average_fn = .average.py: uma função de ordem superior para a clacular uma média contínua
ex_average_demo1 = .Testando o <<ex_average_fn>>
closure_fig = .A clausura para `averager` estende o escopo daquela função para incluir a vinculação da variável livre `series`.
ex_average_demo2 = .Inspecionando a função criada por `make_averager` no <<ex_average_fn>>
ex_average_demo3 = .Continuando do <<ex_average_demo1>>
nonlocal_sec = A declaração nonlocal
ex_average_broken = .Um função de ordem superior incorreta para calcular um média contínua sem manter todo o histórico
ex_average_fixed = .Calcula uma média contínua sem manter todo o histórico (corrigida com o uso de `nonlocal`)
var_lookup_logic_sec = A lógica da consulta de variáveis
ex_clockdeco0 = ._clockdeco0.py_: decorador simples que mostra o tempo de execução de funções
ex_clockdeco_demo = .Usando o decorador `clock`
ex_clockdeco2 = ._clockdeco.py_: um decorador `clock` melhora
memoization_sec = Memoização com functools.cache
ex_fibo_demo = .O modo recursivo e extremamente dispendioso de calcular o _enésimo_ número na série de Fibonacci
fibo_demo_cache_ex = .Implementação mais rápida, usando _caching_
stacked_decorators_tip = .Decoradore empilhados
lru_cache_sec = Usando o lru_cache
generic_functions = Funções genéricas com despacho único
singledispatch_demo = .`htmlize()` gera HTML adaptado para diferentes tipos de objetos
singledispatch_ex = .`@singledispatch` cria uma `@htmlize.register` customizada, para empacotar várias funções em uma função genérica
parameterized_dec_sec = Decoradores parametrizados
registration_ex_repeat = .O módulo registration.py resumido, do <<registration_ex>>, repetido aqui por conveniência
registration_param_ex = .Para aceitar parâmetros, o novo decorador `register` precisa ser invocado como uma função
registration_param_demo = .Usando o módulo registration_param listado no <<registration_param_ex>>
clockdeco_param_ex = .Módulo clockdeco_param.py: o decorador `clock` parametrizado
ex_clockdecoparam_demo1 = .clockdeco_param_demo1.py
ex_clockdecoparam_demo2 = .clockdeco_param_demo2.py
clockdeco_param_cls_ex = .Módulo clockdeco_cls.py: decorador parametrizado `clock`, implementado como uma classe
decorator_further = Leitura complementar
closures_soapbox = .Ponto de vista

[ch_design_patterns]
strategy_case_study = Estudo de caso: refatorando Estratégia
strategy_uml = .Diagrama de classes UML para o processamento de descontos em um pedido, implementado com o padrão de projeto Estratégia.
ex_classic_strategy = .Implementação da classe `Order` com estratégias de desconto intercambiáveis
ex_classic_strategy_tests = .Amostra de uso da classe `Order` com a aplicação de diferentes promoções
pythonic_strategy = Estratégia baseada em funções
ex_strategy = .A classe `Order` com as estratégias de descontos implementadas como funções
ex_strategy_tests = .Amostra do uso da classe `Order` com as promoções como funções
ex_strategy_best_tests = .A funcão `best_promo` aplica todos os descontos e devolve o maior
ex_strategy_best = .`best_promo` encontra o desconto máximo iterando sobre uma lista de funções
ex_strategy_best2 = .A lista `promos` é construída a partir da introspecção do espaço de nomes global do módulo
ex_strategy_best3 = .A lista `promos` é construída a partir da introspecção de um novo módulo, `promotions`
decorated_strategy = Padrão Estratégia aperfeiçoado com um decorador
ex_strategy_best31 = .A lista `promos` é preenchida pelo decorador `promotion`
command_uml = .Diagrama de classes UML para um editor de texto controlado por menus, implementado com o padrão de projeto Comando. Cada comando pode ter um receptor (_receiver_) diferente: o objeto que implementa a ação. Para `PasteCommand`, o receptor é Document. Para `OpenCommand`, o receptor á a aplicação.
ex_macro_command = .Cada instância de `MacroCommand` tem uma lista interna de comandos
design_patterns_summary = Resumo do Capítulo
dp_further = Leitura complementar

[ch_pythonic_obj]
object_repr_sec = Representações de objetos
ex_vector2d_v0_demo = .Instâncias de `Vector2d` têm várias representações
ex_vector2d_v0 = .vector2d_v0.py: todos os métodos até aqui são métodos especiais
ex_vector2d_v1 = .Parte de vector2d_v1.py: esse trecho mostra apenas o método de classe `frombytes`, acrescentado à definição de `Vector2d` em vector2d_v0.py (no <<ex_vector2d_v0>>)
classmethod_x_staticmethod_sec = classmethod versus staticmethod
ex_class_staticmethod = .Comparando o comportamento de `classmethod` e `staticmethod`
format_display_sec = Exibição formatada
ex_format_t1 = .O método `+Vector2d.__format__+`, versão #1
ex_format_t2 = .O método `+Vector2d.__format__+`, versão #2, agora com coordenadas polares
hashable_vector2d = Um Vector2d _hashable_
ex_vector2d_v3 = .vector2d_v3.py: apenas as mudanças necessárias para tornar `Vector2d` imutável são exibidas aqui; a listagem completa está no <<ex_vector2d_v3_full>>
ex_vector2d_v3_hash = .vector2d_v3.py: implementação de __hash__
positional_pattern_implement_sec = Suportando o pattern matching posicional
vector_match_keyword_ex = .Padrões nomeados para sujeitos `Vector2d`—requer Python 3.10
vector_match_positional_ex = .Padrões posicionais para sujeitos `Vector2d`—requer Python 3.10
ex_vector2d_v3_full = .vector2d_v3.py: o pacote completo
private_protected_sec = Atributos privados e "protegidos" no Python
name_mangling_ex = .Nomes de atributos privados são "desfigurados", prefixando-os com o `_` e o nome da classe
safety_fig = .Uma cobertura sobre um interruptor é um dispositivo de proteção, não de segurança: ele previne acidentes, não sabotagem
slots_section = Economizando memória com pass:[__slots__]
slots_ex1 = .A classe `Pixel` usa `+__slots__+`
slots_ex2 = .`OpenPixel` é uma subclasse de `Pixel`
slots_ex3 = .The `ColorPixel`, another subclass of `Pixel`
ex_vector2d_v3_slots = .vector2d_v3_slots.py: o atributo `+__slots__+` é a única adição a `Vector2d`
mem_test_demo = .mem_test.py cria 10 milhões de instâncias de `Vector2d`, usando a classe definida no módulo nomeado
problems_with_slots = Resumindo os problemas com &#x5f;&#x5f;slots&#x5f;&#x5f;
overriding_class_attributes = Sobrepondo atributos de classe
typecode_instance_demo = .Personalizando uma instância pela definição do atributo `typecode`, que antes era herdado da classe
typecode_subclass_demo = .O `ShortVector2d` é uma subclasse de `Vector2d`, que apenas sobrescreve o `typecode` default
pythonic_further_reading = Leitura complementar
pythonic_soapbox = .Ponto de Vista
ex_java_confidential_class = .Confidential.java: uma classe Java com um campo privado chamado `secret`
ex_expose_py = .expose.py: código em Jython para ler o conteúdo de um campo privado em outra classe

[ch_seq_methods]
vector_take1_sec = Vector versão #1: compatível com Vector2d
ex_vector_demo = .Testes de pass:[<code>Vector.&#x5f;&#x5f;init&#x5f;&#x5f;</code>] e pass:[<code>Vector.&#x5f;&#x5f;repr&#x5f;&#x5f;</code>]
ex_vector_v1 = .vector_v1.py: derived from vector2d_v1.py
protocol_duck_section = Protocolos e o _duck typing_
ex_pythonic_deck_rep = .Código do <<ex_pythonic_deck>>, reproduzido aqui por conveniência
sliceable_sequence = Vector versão #2: Uma sequência fatiável
how_slicing_works = Como funciona o fatiamento
ex_slice0 = .Examinando o comportamento de `+__getitem__+` e fatias
ex_slice1 = .Inspecionando os atributos da classe `slice`
slice_aware_sec = Um &#x5f;&#x5f;getitem&#x5f;&#x5f; que trata fatias
ex_vector_v2 = .Parte de vector_v2.py: métodos `+__len__+` e `+__getitem__+` adicionados à classe `Vector`, de vector_v1.py (no <<ex_vector_v1>>)
ex_vector_v2_demo = .Testes do `+Vector.__getitem__+` aperfeiçoado, do <<ex_vector_v2>>
vector_dynamic_attrs_sec = Vector versão #3: acesso dinâmico a atributos
ex_vector_v3_getattr = .Parte de _vector_v3.py_: método `+__getattr__+` acrescentado à classe `Vector`
ex_vector_v3_getattr_bug = .Comportamento inapropriado: realizar uma atribuição a `v.x` não gera um erro, mas introduz uma inconsistência
ex_vector_v3_setattr = .Parte de vector_v3.py: o método `+__setattr__+` na classe `Vector`
multi_hashing = Vector versão #4: o hash e um == mais rápido
reduce_fig = .Funções de redução—`reduce`, `sum`, `any`, `all`—produzem um único resultado agregado a partir de uma sequência ou de qualquer objeto iterável finito.
ex_reduce_xor = .Três maneiras de calcular o xor acumulado de inteiros de 0 a 5
ex_vector_v4 = .Parte de vector_v4.py: duas importações e o método `+__hash__+` adicionados à classe `Vector` de vector_v3.py
map_reduce_fig = .Map-reduce: aplica uma função a cada item para gerar uma nova série (map), e então computa o agregado (reduce).
ex_eq_loop = .A implementação de `+Vector.__eq__+` usando `zip` em um loop `for`, para uma comparação mais eficiente
ex_eq_all = .A implementação de `+Vector.__eq__+` usando `zip` e `all`: mesma lógica do <<ex_eq_loop>>
zip_box = .O fantástico zip
zip_demo = .A função embutida `zip` trabalhando
ex_vector_v5 = .vector_v5.py: doctests e todo o código da versão final da classe `Vector`; as notas explicativas enfatizam os acréscimos necessários para suportar `+__format__+`
sequence_hacking_soapbox = .Ponto de vista

[ch_ifaces_prot_abc]
type_systems_described = .A metade superior descreve abordagens de checagem de tipo durante a execução usando apenas o interpretador Python; a metade inferior requer um verificador de tipo estático externo, como o Mypy ou um IDE como o PyCharm. Os quadrantes da esquerda se referem a tipagem baseada na estrutura do objeto - isto é, dos métodos oferecidos pelo objeto, independente do nome de sua classe ou superclasses; os quadrantes da direita dependem dos objetos terem tipos explicitamente nomeados: o nome da classe do objeto, ou o nome de suas superclasses.
two_kinds_protocols_sec = Dois tipos de protocolos
ex_minimal_sequence = .Implementação parcial do protocolo de sequência usando `+__getitem__+`
prog_ducks_sec = Programando patos
python_digs_seq_sec = Python curte sequências
sequence_uml_repeat = .Diagrama de classe UML para a ABC `Sequence` e classes abstratas relacionadas de `collections.abc`. As setas de herança apontam de uma subclasse para suas superclasses. Nomes em itálico são métodos abstratos. Antes de Python 3.6, não existia uma ABC `Collection` - `Sequence` era uma subclasse direta de `Container`, `Iterable` e `Sized`.
ex_pythonic_deck_repeat = .Um deque como uma sequência de cartas (igual ao <<ex_pythonic_deck>>)
ex_unshuffable = .`random.shuffle` cannot handle `FrenchDeck`
ex_monkey_patch = ."Monkey patching" o `FrenchDeck` para torná-lo mutável e compatível com `random.shuffle` (continuação do <<ex_unshuffable>>)
defensive_duck_prog_sec = Programação defensiva e "falhe rápido"
ex_duck_typing_str_list = .Duck typing para lidar com uma string ou um iterável de strings
goose_typing_sec = Goose typing
waterfowl_essay = .Pássaros aquáticos e as ABCs
ex_pythonic_deck2 = .frenchdeck2.py: `FrenchDeck2`, uma subclasse de `collections.MutableSequence`
mutablesequence_uml = .Diagrama de classe UML para a ABC `MutableSequence` e suas superclasses em `collections.abc` (as setas de herança apontam das subclasses para as ancestrais; nomes em itálico são classes e métodos abstratos).
abc_in_stdlib_sec = ABCs na Biblioteca Padrão
collections_uml = .Diagrama de classes UML para as ABCs em `collections.abc`.
isinstance_mislead_box = .isinstance com Hashable e Iterable pode enganar você
defining_using_abc_sec = Definindo e usando uma ABC
tombola_uml = .Diagrama UML para uma ABC e três subclasses. O nome da ABC `Tombola` e de seus métodos abstratos estão escritos em _itálico_, segundo as convenções da UML. A seta tracejada é usada para implementações de interface - as estou usando aqui para mostrar que `TomboList` implementa não apenas a interface `Tombola`, mas também está registrada como uma _subclasse virtual_ de `Tombola` - como veremos mais tarde nesse capítulo.pass:[<span data-type="footnote"><span class="roman">«registrada» and «subclasse virtual» não são termos da UML padrão. Estão sendo usados para representar uma relação de classe específica de Python.</span></span>]
ex_tombola_abc = .tombola.py: `Tombola` é uma ABC com dois métodos abstratos e dois métodos concretos.
exc_tree_part = .Parte da hierarquia da classe `Exception`.footnote:[A árvore completa está na seção "5.4. Exception hierarchy" da documentação da _Biblioteca Padrão de Python.]
fake_tombola_ex = .Uma `Tombola` falsa não passa desapercebida
abc_syntax_section = Detalhes da Sintaxe das ABCs
ex_tombola_bingo = .bingo.py: `BingoCage` é uma subclasse concreta de `Tombola`
ex_lotto = .lotto.py: `LottoBlower` é uma subclasse concreta que sobrecarrega os métodos `inspect` e `loaded` de `Tombola`
virtual_subclass_sec = Uma subclasse virtual de uma ABC
tombolist_uml = .Diagrama de classe UML para `TomboList`, subclasse real de `list` e subclassse virtual de `Tombola`.
ex_tombolist = .tombolist.py: a classe `TomboList` é uma subclasse virtual de `Tombola`
register_usage = O Uso de register na Prática
subclasshook_sec = Tipagem estrutural com ABCs
sized_source_code = .Definição de `Sized` no código-fonte de https://fpy.li/13-25[Lib/_collections_abc.py]
static_protocols_sec = Protocolos estáticos
typed_double_sec = A função double tipada
repeatable_protocol_ex = ._double_protocol.py_: a definição de `double` usando um `Protocol`.
runtime_checkable_proto_sec = Protocolos estáticos checados durante a Execução
supportscomplex_ex = .código-fonte do protocolo `typing.SupportsComplex`
repeatable_protocol_demo_ex = .Usando `SupportsComplex` durante a execução
duck_typing_friend_box = .O Duck Typing É Seu Amigo
protocol_type_hints_ignored = Limitações das verificações de protocolo durante a execução
support_typing_proto = Suportando um protocolo estático
ex_vector2d_complex_v4 = ._vector2d_v4.py_: métodos para conversão de e para `complex`
ex_vector2d_complex_v5 = ._vector2d_v5.py_: acrescentando anotações aos métodos mencionados
designing_static_proto_sec = Projetando um protocolo estático
ex_randompick_protocol = ._randompick.py_: definition of `RandomPicker`
ex_randompick_protocol_demo = ._randompick_test.py_: `RandomPicker` em uso
best_protocol_design_sec = Melhores práticas no desenvolvimento de protocolos
ex_randompickload_protocol = ._randompickload.py_: estendendo `RandomPicker`
numbers_abc_proto_sec = As ABCs em numbers e os novos protocolos numéricos
interfaces_further_reading = Para saber mais
interfaces_soapbox = .Ponto de vista
type_systems_languages = .Quatro abordagens para checagem de tipos e algumas linguagens que as usam.

[ch_inheritance]
subclass_builtin_woes = É complicado criar subclasses de tipos embutidos
ex_doppeldict = .Nossa sobreposição de `+__setitem__+` é ignorado pelos métodos `+__init__+` e `+__update__+` to tipo embutido `dict`
ex_other_subclass = .O `+__getitem__+` de `AnswerDict` é ignorado por `dict.update`
ex_userdict_ok = .`DoppelDict2` and `AnswerDict2` funcionam como esperado, porque estendem `UserDict` e não `dict`
mro_section = Herança múltipla e a Ordem de Resolução de Métodos
diamond_uml = .Esquerda: Sequência de ativação para a chamada `leaf1.ping()`. Direita: Sequência de ativação para a chamada `leaf1.pong()`.
ex_diamond = .diamond.py: classes `Leaf`, `A`, `B`, `Root` formam o grafo na <<diamond_uml>>
ex_diamond_demo = .Doctests para chamadas a `ping` e `pong` em um objeto `Leaf`
ex_diamond2 = .diamond2.py: classes para demonstrar a natureza dinâmica de `super()`
tkwidgets_mro_uml = .Esquerda: diagrama UML da classe e das superclasses do componente `Text` do Tkinter. Direita: O longo e sinuoso caminho de `+Text.__mro__+`, desenhado com as setas pontilhadas.
ex_tkinter_text_mro = .MRO de `tkinter.Text`
mixin_classes_sec = Classes mixin
ex_uppermixin = .uppermixin.py: `UpperCaseMixin` suporta mapeamentos indiferentes a maiúsculas/minúsculas
ex_upperdict = .uppermixin.py: duas classes que usam `UpperCaseMixin`
multi_real_world_sec = Herança múltipla no mundo real
ex_threadmixin = .Parte de _Lib/socketserver.py_ no Python 3.10
django_cbv_sec = Mixins de views genéricas no Django
django_view_base_uml = .Diagrama de classes UML do módulo `django.views.generic.base`.
django_view_list_uml = .Diagrama de classe UML para o módulo `django.views.generic.list`. Aqui as três classes do módulo base aparecem recolhidas (veja a <<django_view_base_uml>>). A classe `ListView` não tem métodos ou atributos: é uma classe agregada.
tkinter_uml = .Diagrama de classes resumido da hierarquia de classes de interface gráfica do Tkinter; classes etiquetadas com «mixin» são projetadas para oferecer metodos concretos a outras classes, através de herança múltipla.
favor_composition_sec = Prefira a composição de objetos à herança de classes
aggregate_class_sec = Ofereça classes agregadas aos usuários
inheritance_summary = Resumo do capítulo
inheritance_further_reading = Leitura complementar

[ch_more_types]
overload_sec = Assinaturas sobrepostas
sum_overload_ex = ._mysum.py_: definição da função `sum` com assinaturaas sobrepostas
max_overload_sec = Sobreposição máxima
mymax_ex = ._mymax.py_: Versão da funcão `max` em Python
mymax_types_ex = ._mymax.py_: início do módulo, com importações, definições e sobreposições
typeddict_sec = TypedDict
bookdict_ex = ._books.py_: a definição de `BookDict`
bookdict_first_use_ex = .Usando um `BookDict`, mas não exatamente como planejado
bookdict_demo_ex = ._demo_books.py_: operações legais e ilegais em um `BookDict`
bookdict_demo_check = .Verificando os tipos em _demo_books.py_
to_xml_ex = ._books.py_: a função `to_xml`
from_json_any_ex = .books_any.py: a função `from_json`
from_json_ex = .books.py: a função `from_json` com uma anotação de variável
bookdict_demo_not_book_ex = .demo_not_book.py: `from_json` devolve um `BookDict` inválido, e `to_xml` o aceita
bookdict_demo_not_book_check = .Relatório do Mypy para _demo_not_book.py_, reformatado por legibilidade
bookdict_demo_not_book_run = .Resultado da execução de `demo_not_book.py`
type_casting_sec = Coerção de Tipo
runtime_annot_sec = Lendo dicas de tipo durante a execução
ex_clip_annot = .clipannot.py: a assinatura anotada da função `clip`
problems_annot_runtime_sec = Problemas com anotações durante a execução
impl_generic_class_sec = Implementando uma classe genérica
ex_generic_lotto_demo = .generic_lotto_demo.py: usando uma classe genérica de sorteio de bingo
ex_generic_lotto_errors = .generic_lotto_errors.py: erros apontados pelo Mypy
ex_generic_lotto = .generic_lotto.py: uma classe genérica de sorteador de bingo
variance_sec = Variância
invariant_dispenser_types_ex = .invariant.py: definições de tipo e função `install`
covariant_dispenser_types_ex = ._covariant.py_: type definitions and `install` function
contravariant_trash_ex = ._contravariant.py_: definições de tipo e a função `install`
covariant_types_sec = Tipos covariantes
contravariant_types_sec = Tipos contravariantes
variance_rules_sec = Regras gerais de variância
implementing_generic_static_proto_sec = Implementando um protocolo estático genérico
ex_abs_demo = ._abs_demo.py_: uso do protocolo genérico `SupportsAbs`
ex_generic_randompick_protocol = ._generic_randompick.py_: definição do `RandomPicker` genérico
more_type_hints_further_sec = Leitura complementar
typing_peps_tbl = .PEPs sobre dicas de tipo, com links nos títulos. PEPs com números marcados com * são importantes o suficiente para serem mencionadas no parágrafo de abertura da https://docs.python.org/pt-br/3/library/typing.html[documentação de `typing`]. Pontos de interrogação na coluna Python indica PEPs em discussão ou ainda não implementadas; "n/a" aparece em PEPs informacionais sem relação com uma versão específica de Python. Todos os textos das PEPs estão em inglês. Dados coletados em maio 2021.
type_hints_in_classes_soapbox = .Ponto de Vista

[ch_op_overload]
op_overloading_101_sec = Introdução à sobrecarga de operadores
ex_vector_v6_unary = .vector_v6.py: unary operators - and + added to <<ex_vector_v5>>
when_plus_x_sec = .Quando x e +x não são iguais
ex_unary_plus_decimal = .Uma mudança na precisão do contexto aritmético pode fazer `x` se tornar diferente de `+x`
ex_unary_plus_counter = .O + unário produz um novo `Counter`sem as contagens negativas ou zero
overloading_plus_sec = Sobrecarregando + para adição de Vector
ex_vector_add_t1 = .Método `+Vector.__add__+`, versão #1
ex_vector_add_demo_mixed_ok = .Nossa versão #1 de `+Vector.__add__+` também aceita objetos diferentes de ++Vector++
ex_vector_add_demo_mixed_fail = .A versão #1 de `+Vector.__add__+` falha com se o operador da esquerda não for um `Vector
operator_flowchart = .Fluxograma para computar `a + b` com `+__add__+` e `+__radd__+`.
ex_vector_add_t2 = .Os  métodos `+__add__+` e `+__radd__+` de `Vector`
ex_vector_error_iter = .O método `+Vector.__add__+` precisa de operandos iteráveis
ex_vector_error_iter_not_add = .O método `+Vector.__add__+` precisa de um iterável com itens numéricos
ex_vector_v6 = .vector_v6.py: métodos do operador `+` adicionados a vector_v5.py (no <<ex_vector_v5>>)
overloading_mul = Sobrecarregando * para multiplicação escalar
ex_vector_v7 = .vector_v7.py: métodos do operador `*` adicionados
matmul_operator_sec = Usando @ como operador infixo
ex_vector_v7_matmul = .vector_v7.py: operator `@` methods
zip_strict_tip = .O novo recurso de zip() no Python 3.10
infix_operator_names_tbl = .Nomes dos métodos de operadores infixos (os operadores "no mesmo lugar" são usados para atribuição aumentada; operadores de comparação estão na <<reversed_rich_comp_op_tbl>>)
rich_comp_op_sec = Operadores de comparação cheia
reversed_rich_comp_op_tbl = .Operadores de comparação cheia: métodos reversos invocados quando a chamada inicial ao método devolve `NotImplemented`
eq_initial_demo = .Comparando um `Vector` a um `Vector`, a um `Vector2d`, e a uma `tuple`
ex_vector_v8_eq = .vector_v8.py: `+__eq__+` aperfeiçoado na classe `Vector`
eq_demo_new_eq = .Mesmas comparações do <<eq_initial_demo>>: o último resultado mudou
augmented_assign_ops = Operadores de atribuição aumentada
eq_demo_augm_assign_immutable = .Usando `+=` e `*=` com instâncias de `Vector`
demo_addable_bingo_add = .O operador `+` cria uma nova instância de `AddableBingoCage`
demo_addable_bingo_iadd = .Uma `AddableBingoCage` existente pode ser carregada com `+=` (continuando do <<demo_addable_bingo_add>>)
ex_addable_bingo = .bingoaddable.py: `AddableBingoCage` estende `BingoCage` para suportar `+` e `+=`
further_reading_op_sec = Leitura complementar
operator_soapbox = .Ponto de Vista
ex_vector_error_iter_not_add_repeat = .Mesmo que o <<ex_vector_error_iter_not_add>>

[ch_generators]
ex_sentence0 = .sentence.py: uma `Sentence` como uma sequência de palavras
demo_sentence0 = .Testando a iteração em uma instância de `Sentence`
iter_func_sec = Porque sequências são iteráveis: a função iter
iter_closer_look = Usando iter com um invocável
iterable_fig = .As ABCs `Iterable` e `Iterator`. Métodos em itálico são abstratos. Um `+Iterable.__iter__+` concreto deve devolver uma nova instância de `Iterator`. Um `Iterator` concreto deve implementar `+__next__+`. O método `+Iterator.__iter__+` apenas devolve a própria instância.
abc_iterator_src = .Classe `abc.Iterator`; extraído de https://fpy.li/17-5[__Lib/_collections_abc.py__]
ex_sentence1 = .sentence_iter.py: `Sentence` implementada usando o padrão _Iterator_
iterable_not_self_iterator_sec = Não torne o iterável também um iterador
ex_sentence2 = .sentence_gen.py: `Sentence` implementada usando uma geradora
gen-func-ex-three-yield = .Uma função geradora que produz três números((("generators", "examples of", id="genex17")))
ex_gen_ab = .Uma função geradora que exibe mensagens quando roda
ex_sentence3 = .sentence_gen2.py: `Sentence` implementada usando uma função geradora que invoca a função geradora `re.finditer`
ex_gen_ab_genexp = .A função geradora `gen_AB` é usada primeiro por uma compreensão de lista, depois por uma expressão geradora
ex_sentence4 = .sentence_genexp.py: `Sentence` implementada usando uma expressão geradora
ap_class_demo = .Demonstração de uma classe `ArithmeticProgression`
ex_ap_class = .A classe `ArithmeticProgression`
ex_ap_genfunc1 = .a função geradora `aritprog_gen`
ap_itertools_sec = Progressão aritmética com itertools
ex_almost_aritprog = .aritprog_v3.py: funciona como as funções `aritprog_gen` anteriores
stdlib_generators = Funções geradoras na biblioteca padrão
filter_genfunc_tbl = .Funções geradoras de filtragem
demo_filter_genfunc = .Exemplos de funções geradoras de filtragem
mapping_genfunc_tbl = .Funções geradoras de mapeamento
demo_accumulate_genfunc = .Exemplos das funções geradoras de `itertools.accumulate`
demo_mapping_genfunc = .Exemplos de funções geradoras de mapeamento
merging_genfunc_tbl = .Funções geradoras que fundem os iteráveis de entrada
demo_merging_genfunc = .Exemplos de funções geradoras de fusão
demo_product_genfunc = .Exemplo da função geradora `itertools.product`
expanding_genfunc_tbl = .Funções geradoras que expandem cada item de entrada em múltiplos itens de saída
demo_count_repeat_genfunc = .`count`, `cycle`, `pairwise`, e `repeat`
demo_conbinatoric_genfunc = .Funções geradoras combinatórias produzem múltiplos valores para cada item de entrada
expanding_genfunc_tbl2 = .Funções geradoras de rearranjo
demo_groupby_reversed_genfunc = .`itertools.groupby`
demo_tee_genfunc = .`itertools.tee` produz múltiplos geradores, cada um produzindo todos os itens do gerador de entrada
iterable_reducing_sec = Funções de redução de iteráveis
tbl_iter_reducing = .Funções embutidas que leem iteráveis e devolvem um único valor
all_any_demo = .Resultados de `all` e `any` para algumas sequências
yield_from_sec0 = Subgeradoras com yield from
ex_simple_yield_from = .Experimentando `yield from`
ex_simple_yield_from_return = .`yield from` recebe o valor devolvido pelo subgerador
reinventing_chain_sec = Reinventando chain
traversing_tree_sec = Percorrendo uma árvore
ex_tree_step0 = .tree/step0/tree.py: produz o nome da classe raiz e para
ex_tree_step1 = .tree/step1/tree.py: produz o nome da classe raiz e das subclasses diretas
ex_tree_step2 = .tree/step2/tree.py: `tree` produz o nome da classe raiz, e entao delega para `sub_tree`
ex_tree_step3 = .tree/step3/tree.py: `sub_tree` percorre os níveis 1 e 2, primeiro em profundidade
ex_tree_step4 = .A geradora `sub_tree` de _tree/step4/tree.py_
ex_tree_step5 = .tree/step5/tree.py: a `sub_tree` recursiva vai tão longe quanto a memória permitir
ex_tree_step6 = .tree/step6/tree.py: chamadas recursivas de `tree` passam um argumento `level` incrementado
generic_iterable_types_sec = Tipos iteráveis genéricos
replacer_iterable_ex = .replacer.py devolve um iterador de tuplas de strings
fibo_gen_annot_ex = ._fibo_gen.py_: `fibonacci` devolve um gerador de inteiros
iter_gen_type_ex = .itergentype.py: duas formas de anotar iteradores
classic_coroutines_sec = Corrotinas clássicas
ex_coroaverager = .coroaverager.py: corrotina para computar uma média móvel
ex_coroaverager_test = .coroaverager.py: doctest para a corrotina de média móvel do <<ex_coroaverager>>
ex_coroaverager_test_cont = .coroaverager.py: continuando de <<ex_coroaverager_test>>
coro_return_sec = Devolvendo um valor a partir de uma corrotina
ex_returning_averager_top = .coroaverager2.py: a primeira parte do arquivo
ex_returning_averager_coro = .coroaverager2.py: uma corrotina que devolve um valor resultante
ex_coro_averager2_demo_1 = .coroaverager2.py: doctest mostrando `.cancel()`
ex_coro_averager2_demo_2 = .coroaverager2.py: doctest mostrando `StopIteration` com um `Result`
ex_coro_averager2_demo_3 = .coroaverager2.py: doctest mostrando `StopIteration` com um `Result`
generic_classic_coroutine_types_sec = Dicas de tipo genéricas para corrotinas clássicas

[ch_with_match]
context_managers_sec = Gerenciadores de contexto e a instrução with
with_file_demo = .Demonstração do uso de um objeto arquivo como gerenciador de contexto
looking_glass_demo_1 = .Testando a classe gerenciadora de contexto `LookingGlass`
looking_glass_ex = .mirror.py: código da classe gerenciadora de contexto `LookingGlass`
looking_glass_demo_2 = .Exercitando o `LookingGlass` sem um bloco `with`
context_utilities_sec = Utilitários do contextlib
using_cm_decorator_sec = Usando o @contextmanager
looking_glass_gen_ex = .mirror_gen.py: um gerenciador de contexto implementado com um gerador
looking_glass_gen_demo = .Testando a função gerenciadora de contexto `looking_glass`
looking_glass_gen_exc_ex = .mirror_gen_exc.py: gerenciador de contexto baseado em um gerador implementando tratamento de erro—com o mesmo comportamento externo de <<looking_glass_ex>>
looking_glass_gen_deco_demo = .O gerenciador de contexto `looking_glass` também funciona como um decorador.
inplace_ex = .Um gerenciador de contexto para reescrever arquivos no lugar
pattern_matching_case_study_sec = Pattern matching no lis.py: um estudo de caso
ex_gcd_scheme = .Maior divisor comum em Scheme
ex_gcd_python = .Igual ao <<ex_gcd_scheme>>, mas escrito em Python
lis_top_ex = .lis.py: início do arquivo
lis_parser_ex = .lis.py: as principais funcões do analisador
ast_fig = .Uma expressão `lambda` de Scheme, representada como código-fonte (sintaxe concreta de expressões-S), como uma árvore, e como uma sequência de objetos Python (sintaxe abstrata).
environment_class_ex = ._lis.py_: a classe `Environment`
lis_std_env_ex = .lis.py: `standard_env()` constrói e devolve o ambiente global
ex_lispy_repl = .As funções do REPL
ex_evaluate_match = .`evaluate` recebe uma expressão e calcula seu valor
eval_atom_sec = avaliando números
test_case_defun = .Definindo uma função chamada `%`, que calcula uma porcentagem
function_call_sec = Chamada de função
further_reading_context_sec = Para saber mais
soapbox_with_match = .Ponto de vista

[ch_concurrency_models]
concurrent_hello_world = Um "Olá mundo" concorrente
spinner_fig = .Os scripts spinner_thread.py e spinner_async.py produzem um resultado similar: o repr do objeto spinner e o texto "Answer: 42". Na captura de tela, spinner_async.py ainda está rodando, e a mensagem animada "/ thinking!" é apresentada; aquela linha será substituída por "Answer: 42" após 3 segundos.
spinner_thread_top_ex = .spinner_thread.py: as funções `spin` e `slow`
spinner_thread_rest_ex = .spinner_thread.py: as funções `supervisor` e `main`
spinner_proc_ex = .spinner_proc.py: apenas as partes modificadas são mostradas; todo o resto é idêntico a spinner_thread.py
spinner_async_sec = Animação com corrotinas
spinner_async_start_ex = .spinner_async.py: a função `main` e a corrotina `supervisor`
spinner_async_top_ex = .spinner_async.py: as corrotinas `spin` e `slow`
spinner_async_time_sleep_ex = .spinner_async.py: substituindo `await asyncio.sleep(3)` por `time.sleep(3)`
spinner_async_experiment_ex = .spinner_async_experiment.py: as corrotinas `supervisor` e `slow`
gevent_box = .Greenlet e gevent
thread_supervisor_ex = .spinner_thread.py: a função `supervisor` com threads
asyncio_supervisor_ex = .spinner_async.py: a corrotina assíncrona `supervisor`
def_is_prime_ex = .primes.py: uma verificação de números primos fácil de entender, do exemplo em https://docs.python.org/pt-br/3/library/concurrent.futures.html#processpoolexecutor-example[pass:[<code>ProcessPool&#x200b;Executor</code>] na documentação de Python]
example-19-11 = .spinner_async_nap.py: `is_prime` agora é uma corrotina
naive_multiprocessing_sec = Um pool de processos caseiro
primes_sequential_ex = .sequential.py: verificação de números primos em um pequeno conjunto de dados
proc_based_solution = Solução baseada em processos
code_for_multicore_prime_sec = Código para o verificador de números primos com múltiplos núcleos
primes_procs_top_ex = .procs.py: verificação de primos com múltiplos processos; importações, tipos, e funções
good_poison_pill_tip = .Loops, sentinelas e pílulas venenosas
primes_procs_main_ex = .procs.py: verificação de números primos com múltiplos processos; função `main`
procs_x_time_fig = .Mediana dos tempos de execução para cada número de subprocessos de 1 a 20. O maior tempo mediano foi 40,81s, com 1 processo. O tempo mediano mais baixo foi 10,39s, com 6 processos, indicado pela linha pontilhada.
thread_non_solution_sec = Não-solução baseada em threads
py_in_multicore_world_sec = Python no mundo multi-núcleo.
server_side_sec = Desenvolvimento de aplicações server-side para Web/Computação Móvel
one_possible_architecture_fig = .Uma arquitetura possível para um sistema, combinando diversos componentes.footnote:[Diagrama adaptado da Figure 1-1, _Designing Data-Intensive Applications_ de Martin Kleppmann (O'Reilly).]
wsgi_app_server_sec = Servidores de aplicação WSGI
app_server_fig = .Clientes se conectam a um servidor HTTP que entrega arquivos estáticos e roteia outras requisições para o servidor de aplicação, que inicia processo filhos para executar o código da aplicação, utilizando múltiplos núcleos de CPU. A API WSGI é a ponte entre o servidor de aplicação e o código da aplicação Python.
asgi_note = .ASGI—Asynchronous Server Gateway Interface
distributed_task_queues_sec = Filas de tarefas distribuídas
concurrency_further_reading_sec = Para saber mais
concurrency_further_threads_procs_sec = Concorrência com threads e processos
concurrency_models_soapbox = .Ponto de vista

[ch_executors]
ex_web_downloads_sec = Downloads concorrentes da web
ex_flags_sample_runs = .Três execuções típicas dos scripts flags.py, flags_threadpool.py, e flags_asyncio.py
flags_module_ex = .flags.py: script de download sequencial; algumas funções serão reutilizadas pelos outros scripts
downloading_with_futures_sec = Download com concurrent.futures
flags_threadpool_ex = .flags_threadpool.py: script de download com threads, usando `futures.ThreadPoolExecutor`
where_futures_sec = Onde estão os futures?
flags_threadpool_futures_ex = .flags_threadpool_futures.py: substitui `executor.map` por `executor.submit` e `futures.as_completed` na função `download_many`
flags_threadpool_futures_run = .Saída de flags_threadpool_futures.py
launching_processes_sec = Iniciando processos com concurrent.futures
multicore_prime_redux_sec = Verificador de primos multinúcleo redux
proc_pool_py = .proc_pool.py: _procs.py_ reescrito com `ProcessPoolExecutor`
proc_pool_py_output = .Saída de proc_pool.py
demo_executor_map_ex = .demo_executor_map.py: Uma demonstração simples do método map de `ThreadPoolExecutor`
demo_executor_map_run = .Amostra da execução de demo_executor_map.py, do <<demo_executor_map_ex>>
flags2_sec = Download com exibição do progresso e tratamento de erro
careful_testing_clients = .Tenha cuidado ao testar clientes concorrentes
flags2_progress_fig = .Acima, à esquerda: flags2_threadpool.py rodando com a barra de progresso em tempo real gerada pelo tqdm; Abaixo, à direita: mesma janela do terminal após o script terminar de rodar.
flags2_help_demo = .Tela de ajuda dos scripts da série flags2
setting_up_servers_box = .Configurando os servidores de teste
flags2_sequential_run = .Rodando flags2_sequential.py com todos os defaults: `site LOCAL`, as 20 bandeiras dos países mais populosos, 1 conexão concorrente
flags2_threadpool_run = .Roda flags2_threadpool.py para obter do servidor `DELAY` todas as bandeiras com prefixos de códigos de país A, B ou C
flags2_asyncio_run = .Roda flags2_asyncio.py para baixar 100 bandeiras (`-al 100`) do servidor `ERROR`, usando 100 requisições concorrentes (`-m 100`)
flags2_basic_http_ex = .flags2_sequential.py: funções básicas encarregadas dos downloads; ambas são reutilizadas no flags2_threadpool.py
flags2_download_many_seq = .flags2_sequential.py: a implementação sequencial de `download_many`
using_futures_as_completed_sec = Usando futures.as_completed
flags2_threadpool_full = .flags2_threadpool.py: listagem completa

[ch_async]
blogdom_ex = .blogdom.py: procura domínios para um blog sobre Python
flags_asyncio_sec = Downloads com asyncio e HTTPX
flags_asyncio_start_ex = .flags_asyncio.py: funções de inicialização
flags_asyncio_ex = .flags_asyncio.py: imports and download functions
await_channel_fig = .Em um programa assíncrono, uma função do usuário inicia o loop de eventos, agendando uma corrotina inicial com `asyncio.run`. Cada corrotina do usuário aciona a seguinte com uma expressão `await`, formando um canal que permite a comunicação entre uma biblioteca como a _HTTPX_ e o loop de eventos.
async_context_manager_sec = Gerenciadores de contexto assíncronos
asyncpg_transaction_no_context_ex = .Código exemplo da documentação do driver PostgreSQL _asyncpg_
flags2_asyncio_sec = Melhorando o download de bandeiras asyncio
flags2_asyncio_run_repeat = .Running flags2_asyncio.py
using_as_completed_sec = Usando asyncio.as_completed e uma thread
flags2_asyncio_top = .flags2_asyncio.py: parte superior (inicial) do script; o resto do código está no <<flags2_asyncio_rest>>
about_semaphores_box = .Semáforos no Python
flags2_asyncio_rest = .flags2_asyncio.py: continuação de <<flags2_asyncio_top>>
flags3_asyncio_get_country = .flags3_asyncio.py: corrotina `get_country`
flags3_asyncio = .flags3_asyncio.py: corrotina `download_one`
delegating_to_executors_sec = Delegando tarefas a executores
flags2_asyncio_executor_fragment = .Linhas para usar no lugar de `await asyncio.to_thread`
web_mojifinder_result = .Janela de navegador mostrando os resultados da busca por "mountain" no serviço web_mojifinder.py.
inverted_index_fig = .Explorando o atributo `entries` e o método `search` de `InvertedIndex` no console de Python
fastapi_web_service_sec = Um serviço web com FastAPI
web_mojifinder_schema = .Schema OpenAPI gerado automaticamente para o ponto de acesso `/search`.
web_mojifinder_ex = .web_mojifinder.py: código-fonte completo
tcp_mojifinder_demo = .Sessão de telnet com o servidor tcp_mojifinder.py: consultando "fire."
tcp_mojifinder_main = .tcp_mojifinder.py: um servidor TCP simples; continua em <<tcp_mojifinder_top>>
tcp_mojifinder_server_demo = .tcp_mojifinder.py: isso é o lado servidor da sessão mostrada na <<tcp_mojifinder_demo>>
tcp_mojifinder_top = .tcp_mojifinder.py: continuação de <<tcp_mojifinder_main>>
tcp_mojifinder_search = .tcp_mojifinder.py: corrotina `search`
async_gen_func_sec = Funções geradoras assíncronas
python_async_console_sec = Experimentando com o console assíncrono de Python
domainlib_demo_repl = .Experimentando com _domainlib.py_ após executar `python3 -m asyncio`
domainlib_more_exp_repl = .mais experimentos, continuando de <<domainlib_demo_repl>>
domainlib_ex = .domainlib.py: funções para sondar domínios
domaincheck_ex = .domaincheck.py: utilitário para sondar domínios usando domainlib
async_gen_context_mngr_sec = Geradores assíncronos como gerenciadores de contexto
asynccontextmanager_ex = .Exemplo usando `@asynccontextmanager` e `loop.run_in_executor`
blogdom_curio_ex = .blogdom.py: <<blogdom_ex>>, agora usando o _Curio_
how_async_works_and_does_not_sec = Como a programação assíncrona funciona e como não funciona
around_blocking_calls_sec = Correndo em círculos em torno de chamadas bloqueantes
latency_tbl = .Latência de computadores modernos para ler dados em diferentes dispositivos. A terceira coluna mostra os tempos proporcionais em uma escala fácil de entender para nós, humanos vagarosos.
myth_iobound_sec = O mito dos sistemas limitados por E/S
avoid_cpu_trap_sec = Evitando as armadilhas do uso da CPU
async_soapbox = .Ponto de vista

[ch_dynamic_attrs]
ex_osconfeed_json = .Amostra de registros do osconfeed.json; o conteúdo de alguns campos foi abreviado
ex_osconfeed_explore = .Exploração interativa do osconfeed.json
ex_explore0_demo = .`FrozenJSON`, do <<ex_explore0>>, permite ler atributos como `name`, e invocar métodos como `++.keys()++` e `++.items()++`
ex_explore0 = .explore0.py: transforma um conjunto de dados JSON em um `FrozenJSON` contendo objetos `FrozenJSON` aninhados, listas e tipos simples
dynamic_names_sec = O problema do nome de atributo inválido
ex_explore1 = .explore1.py: anexa um `_` a nomes de atributo que sejam palavraas reservadas de Python
flexible_new_sec = Criação flexível de objetos com &#x5f;&#x5f;new&#x5f;&#x5f;
ex_explore2 = .explore2.py: usando `+__new__+` em vez de `build` para criar novos objetos, que podem ou não ser instâncias de `FrozenJSON`
computed_props_sec = Propriedades computadas
ex22-7-added-uuid = .Ler `venue` e `speakers` devolve objetos `Record`
ex_schedule_v1_demo = .Testando schedule_v1.py (do <<ex_schedule_v1>>)
ex_schedule_v1 = .schedule_v1.py: reorganizando os dados de agendamento da OSCON
oscon_schedule_v2_sec = Passo 2: Propriedades para recuperar um registro relacionado
ex_schedule_v2_demo = .Extratos dos doctests de schedule_v2.py
ex_schedule_v2_record = .schedule_v2.py: a classe `Record` com um novo método `fetch`
ex_schedule_v2_event = .schedule_v2.py: a classe `Event`
ex_schedule_v2_load = .schedule_v2.py: a função `load`
property_overriding_sec = Passo 3: Uma propriedade sobrescrevendo um atributo existente
ex_schedule_v3_speakers = .schedule_v3.py: a propriedade `speakers`
cached_property_sec = Passo 4: Um _cache_ de propriedades sob medida
ex_schedule_v4_hasattr = .A lógica de _caching_ customizada usando `hasattr` desabilita a otimização de compartilhamento de chaves
ex_schedule_v4 = .Armazenamento definido em `+__init__+` para manter a otimização de compartilhamento de chaves
caching_properties_sec = Passo 5: _Caching_ de propriedades com functools
ex_schedule_v5_cached_property = .Uso simples de uma `@cached_property`
ex_schedule_v5_property_over_cache = .Stacking `@property` sobre `@cache`
prop_validation_sec = Usando uma propriedade para validação de atributos
lineitem_class_v1 = .bulkfood_v1.py: a classe `LineItem` mais simples
lineitem_problem_v1 = .Um peso negativo resulta em um subtotal negativo
lineitem_class_v2 = .bulkfood_v2.py: um `LineItem` com uma propriedade `weight`
lineitem_class_v2b = .bulkfood_v2b.py: igual ao <<lineitem_class_v2>>, mas sem usar decoradores
prop_override_instance = Propriedades sobrescrevem atributos de instância
attr_override_demo1 = .Atributo de instância oculta o atributo de classe `data`
attr_override_demo2 = .Um atributo de instância não oculta uma propriedade da classe (continuando do <<attr_override_demo1>>)
attr_override_demo3 = .Uma nova propriedade de classe oculta o atributo de instância existente (continuando do <<attr_override_demo2>>)
help_foo_screens = .Capturas de tela do console de Python para os comandos `help(Foo.bar)` e `help(Foo)`. O código-fonte está no <<ex_foo_property_doc>>.
ex_foo_property_doc = .Documentação para uma propriedade
coding_prop_factory_sec = Criando uma fábrica de propriedades
lineitem_class_v2prop_class = .bulkfood_v2prop.py: a fábrica de propriedades `quantity` em ação
lineitem_class_v2prop = .bulkfood_v2prop.py: a fábrica de propriedades `quantity`
lineitem_class_v2prop_demo = .bulkfood_v2prop.py: explorando propriedades e atributos de armazenamento
attribute_deletion_sec = Tratando a exclusão de atributos
ex_black_knight = .blackknight.py
demo_black_knight = .blackknight.py: doctests para <<ex_black_knight>> (o Cavaleiro Negro nunca reconhece a derrota)
bif_attribute_handling = Funções embutidas para tratamento de atributos
special_methods_for_attr_sec = Métodos especiais para tratamento de atributos
properties_soapbox = .Ponto de Vista

[ch_descriptors]
whats_new_descriptor_sec = Novidades nesse capítulo
validating_descriptor_sec = Exemplo de descritor: validação de atributos
lineitem3_uml = .Diagrama de classe UML para `LineItem` usando uma classe descritora chamada `Quantity`. Atributos sublinhados no UML são atributos de classe. Observe que `weight` e `price` são instâncias de `Quantity` na classe `LineItem`, mas instâncias de `LineItem` também têm seus próprios atributos `weight` e `price`, onde esses valores são armazenados.
lineitem3_uml_mgn = .Diagrama de classe UML anotado com MGN (Mills & Gizmos Notation - Notação de Engenhocas e Bugigangas): classes são engenhocas que produzem bugigangas—as instâncias. A engenhoca `Quantity` produz duas bugigangas de cabeça redonda, que são anexadas à engenhoca `LineItem`: `weight` e `price`. A engenhoca `LineItem` produz bugigangas retangulares que tem seus próprios atributos `weight` e `price`, onde aqueles valores são armazenados.
mgn_box1 = .Introduzindo a notação Engenhocas & Bugigangas (_Mills & Gizmos_)
mgn_diagram_demo = .Esboço MGN mostrando a classe `LineItem` produzindo três instâncias, e `Quantity` produzindo duas. Uma instância de `Quantity` está recuperando um valor armazenado em uma instância de `LineItem`.
quantity_v3 = .bulkfood_v3.py: o descritor `Quantity` não aceita valores negativos
lineitem_class_v3 = .bulkfood_v3.py: descritores `Quantity` gerenciam atributos em `LineItem`
auto_storage_sec = LineItem versão #4: Nomeando atributos de armazenamento automaticamente
lineitem_class_v4 = .bulkfood_v4.py: `+__set_name__+` define o nome para cada instância do descritor `Quantity`
lineitem_class_v4c = .bulkfood_v4c.py: uma definição mais limpa de `LineItem`; a classe descritora `Quantity` agora reside no módulo importado `model_v4c`
new_descr_type_sec = LineItem versão #5: um novo tipo descritor
model_v5_abc = .model_v5.py: the `Validated` ABC
model_v5_sub = .model_v5.py: `Quantity` e `NonBlank`, subclasses concretas de `Validated`
lineitem_class_v5 = .bulkfood_v5.py: `LineItem` usando os descritores `Quantity` e `NonBlank`
descriptorkinds_ex = .descriptorkinds.py: classes simples para estudar os comportamentos dominantes de descritores
overriding_descriptor_sec = Descritores dominantes
descriptorkinds_demo1 = .O comportamento de um descritor dominante
descriptorkinds_demo2 = .Descritor dominante sem `+__get__+`
descriptorkinds_demo3 = .Comportamento de um descritor não dominante
descriptorkinds_demo4 = .Qualquer descritor pode ser sobrescrito na própria classe
methods_are_descriptors_sec = Métodos são descritores
descriptorkinds_demo5 = .Um método é um descritor não dominante
func_descriptor_ex = .method_is_descriptor.py: uma classe `Text`, derivada de `UserString`
func_descriptor_demo = .Experimentos com um método
descriptor_usage_sec = Dicas para o uso de descritores
descriptor_doc_del_sec = Docstrings de descritores e a sobreposição de exclusão
descriptor_help_screens = .Capturas de tela do console de Python após os comandos `help(LineItem.weight)` e `help(LineItem)`.

[ch_class_metaprog]
anatomy_of_classes = Classes como objetos
record_factory_demo = .Testando `record_factory`, uma fábrica de classes simples
record_factory_ex = .record_factory.py: uma classe fábrica simples
enhancing_with_init_subclass = Apresentando pass:[__init_subclass__]
checked_demo1_ex = .initsub/checkedlib.py: doctest para a criação de uma subclasse `Movie` de `Checked`
checked_field_ex = .initsub/checkedlib.py: a classe descritora `Field`
checked_class_top_ex = .initsub/checkedlib.py: os métodos mais importante da classe `Checked`
init_subclass_not_typical_box = .pass:[__init_subclass__] não é um método de classe típico
checked_class_bottom_ex = .initsub/checkedlib.py: métodos restantes da classe `Checked`
why_cannot_config_slots_sec = Por que pass:[__init_subclass__] não pode configurar pass:[__slots__]?
checkeddeco_demo1_ex = .checkeddeco.py: criando uma classe `Movie` decorada com `@checked`
checkeddeco_decorators_ex = .checkeddeco.py: o decorador de classes
checkeddeco_methods_ex = .checkeddeco.py: os métodos que serão injetados na classe decorada
import_v_runtime_sec = O que acontece quando: importação versus execução
evaldemo_sec = Experimentos com a fase de avaliação (_evaluation time_)
builderlib_top_ex = .builderlib.py: primeira parte do módulo
builderlib_bottom_ex = .builderlib.py: a parte final do módulo
evaldemo_ex = .evaldemo.py: script para experimentar com _builderlib.py_
evaldemo_console_ex = .Experimentos de console com _evaldemo.py_
evaldemo_script_ex = .Executando _evaldemo.py_ como um programa
metclass101_sec = Introdução às metaclasses
meta_class_and_class_mgn = .Uma metaclasse é uma classe que cria classes.
class_hier_2tops_uml = .Os dois diagramas são verdadeiros. O da esquerda enfatiza que `str`, `type`, e `LineItem` são subclasses de `object`. O da direita deixa claro que `str`, `object`, e `LineItem` são instâncias de `type`, pois todas são classes.
metaclass_abcmeta_uml = .`Iterable` é uma subclasse de `object` e uma instância de `ABCMeta`. Tanto `object` quanto `ABCMeta` são instâncias de `type`, mas a relação crucial aqui é que `ABCMeta` também é uma subclasse de `type`, porque `ABCMeta` é uma metaclasse. Neste diagrama, `Iterable` é a única classe abstrata.
how_metaclass_customizes = Como uma metaclasse customiza uma classe
nice_metaclass_sec = Um belo exemplo de metaclasse
metabunch_ex = .metabunch/from3.6/bunch.py: a metaclasse `MetaBunch` e a classe `Bunch`
evaldemo_meta_ex = .evaldemo_meta.py: experimentando com uma metaclasse
metalib_top_ex = .metalib.py: a classe `NosyDict`
metalib_bottom_ex = .metalib.py: a `MetaKlass`
evaldemo_meta_console_ex = .Experimento com _evaldemo_meta.py_ no console
evaldemo_meta_script_ex = .Rodando _evaldemo_meta.py_ como um programa
checkedlib_uml_mgn = .Diagrama de classes UML com MGN: a meta-engenhoca `CheckedMeta` cria a engenhoca `Movie`. A engenhoca `Field` cria os descritores `title`, `year`, e `box_office`, que são atributos de classe de `Movie`. Os dados de cada instância para os campos são armazenados nos atributos de instância  `+_title+`, `+_year+` e `+_box_office+` de `Movie`. Observe a fronteira do pacote `checkedlib`. O desenvolvedor de `Movie` não precisa entender todo o maquinário dentro de _checkedlib.py_.
checked_field_meta_ex = .metaclass/checkedlib.py: o descritor `Field` com `storage_name` e `+__get__+`
checked_metaclass_ex = .metaclass/checkedlib.py: tha metaclasse `CheckedMeta`
checked_baseclass_ex = .metaclass/checkedlib.py: a classe base `Checked`
metaclases_real_world_sec = Metaclasses no mundo real
metaclass_modern_features_sec = Recursos modernos simplificam ou substituem as metaclasses
metahack_sec = Um _hack_ de metaclasse com +__prepare__+
ch21-furtherreading = Leitura complementar
